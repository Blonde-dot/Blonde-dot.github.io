<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blonde</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-17T17:24:43.684Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Blonde</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP</title>
    <link href="http://example.com/2021/08/30/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/08/30/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-30T13:39:15.000Z</published>
    <updated>2021-09-17T17:24:43.684Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP算法是一种字符串匹配算法，可以在O(m+n)的时间复杂度内实现两个字符串的匹配</p><blockquote><p>字符串匹配问题：字符串P 是否为字符串S的子串？</p></blockquote><p> <strong>S 称作主字符串</strong>，<strong>P称作模式字符串</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98.png"></p><p>KMP算法在于<strong>减少两个字符串之间比较的次数</strong>（字符串比较的复杂度是难降低，基本只能逐个比较）</p><p>KMP通过一个为模板字符串 P 维护的next[]数组，这个next[] 数组有一个特点：</p><p><strong>next[x]  =  P[0] - P[x] 这一段字符串中的最长相等前缀后缀子串的长度</strong></p><blockquote><p>假设存在一个子段k（可能是一个字符或多个）</p><p>k的下标处于 0&lt;k&lt;x,   0-k 与 k - x 的子串完全相等，称这两个相等的子串为前缀、后缀</p></blockquote><p>next数组的核心思想在于 模式字符串<strong>P自己与自己做匹配</strong></p><p><strong>使用 next数组的特性可以跳过不可能成功的字符串比较</strong></p><p>next数组的性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。</p><p>如果字符失配在 P[r], 那么P[0]~P[r-1]这一段里面，<strong>前next[r-1]个字符恰好和后next[r-1]个字符相等</strong></p><p>也就是说，我们可以拿长度为 next[r-1] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去</p><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/%E4%BD%BF%E7%94%A8next%E6%95%B0%E7%BB%84%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p><p>观察这个例子：</p><p>在 S[0] 尝试匹配，失配于 S[3] &lt;=&gt; P[3] 之后，我们直接把模式串往右移了两位，让 S[3] 对准 P[1]. </p><p>接着继续匹配，失配于 S[8] &lt;=&gt; P[6], 接下来我们把 P 往右平移了三位，把 S[8] 对准 P[3]. </p><p>此后继续匹配直到成功</p><p><strong>KMP算法的时间复杂度为 O(M+N)</strong></p><h3 id="next数组的实现"><a href="#next数组的实现" class="headerlink" title="next数组的实现"></a>next数组的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// j : 前缀末尾指针</span></span><br><span class="line"><span class="comment">// i ：后缀末尾指针，默认指向一个子串的最后一位，用于表示i之前的所有字符形成的子串（包含i）</span></span><br><span class="line"><span class="comment">// P : 模板字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] buildNext(String P)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[P.length];</span><br><span class="line">    <span class="comment">// 初始化,第一个字符的没有相同前后缀</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前缀指针指向第一个元素</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 后缀指针一开始指向第二个元素</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 以后缀指针遍历整个模板字符串，i以及i之前的所有字符形成一个子串，查找子串的最长相同前缀后缀</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;P.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 当 i 指向的元素与 j指向的元素不相等时，j回退到next[j-1]的位置，重新进行判断</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; P[i] != P[j])&#123;</span><br><span class="line">            j = next[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当 i 指向的元素 与 j指向的元素相等时，j向后移动一位，即前缀后缀相同子串长度加1</span></span><br><span class="line">        <span class="keyword">if</span>(P[i] = P[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 j 添加到 next[i] 中，表示 i与i之前所有字符形成的子串的最长前缀后缀相等长度就为j</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主串S与模式串P比较实现"><a href="#主串S与模式串P比较实现" class="headerlink" title="主串S与模式串P比较实现"></a>主串S与模式串P比较实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tar : 主串匹配的位置</span></span><br><span class="line"><span class="comment">// pos : 模式串中匹配的位置</span></span><br><span class="line"><span class="comment">// S ：主串</span></span><br><span class="line"><span class="comment">// P ：模式串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Search</span><span class="params">(String S,String P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">this</span>.buildNext(P);</span><br><span class="line">    <span class="comment">// 匹配成功，继续向后匹配</span></span><br><span class="line">    <span class="keyword">if</span>(S[tar] == P[pos])&#123;</span><br><span class="line">        tar++;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( pos != <span class="number">0</span> )&#123; <span class="comment">// 匹配失败且pos不等于0，tar不变，将pos回退到next[pos-1]</span></span><br><span class="line">        pos = next[pos-<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// P[0] 与 S[0] 匹配失败，直接将tar右移一位 </span></span><br><span class="line">        tar++；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos == p.length)&#123; <span class="comment">// pos走到了P的末尾，即匹配成功</span></span><br><span class="line">        System.out.print(tar - pos); <span class="comment">// 输出主串上的匹配起点</span></span><br><span class="line">        pos = next[pos-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.zhihu.com/question/21923021">https://www.zhihu.com/question/21923021</a></p>]]></content>
    
    
    <summary type="html">KMP算法基础</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>join语句的使用</title>
    <link href="http://example.com/2021/08/30/SQL%E5%BC%80%E5%8F%91-join/"/>
    <id>http://example.com/2021/08/30/SQL%E5%BC%80%E5%8F%91-join/</id>
    <published>2021-08-30T13:39:15.000Z</published>
    <updated>2021-09-17T19:05:27.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MySQL-Join的使用"><a href="#MySQL-Join的使用" class="headerlink" title="MySQL - Join的使用"></a>MySQL - Join的使用</h2><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/Join.png"></p><ul><li><p><strong>Inner Join — 内连接</strong></p><ul><li><p>查询出两个表的交集（相同字段）生成新的表</p></li><li><p><code>SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TABLE B B ON A.key = B.key;</code></p><blockquote><p><select_list>：需要插叙出的新表的字段</p><p>A : 自定义TableA的别名，用于表示A表</p><p>B：自定义TableB的别名，用于表示B表</p><p>ON A.key = B.key ：判断条件</p></blockquote></li></ul></li><li><h5 id="Left-Outer-Join-—-左外连接（以连接左边的表作为查询基准）"><a href="#Left-Outer-Join-—-左外连接（以连接左边的表作为查询基准）" class="headerlink" title="Left Outer Join —  左外连接（以连接左边的表作为查询基准）"></a>Left Outer Join —  左外连接（以连接左边的表作为查询基准）</h5><ul><li><p><code>SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TABLEB B ON A.key = B.key;</code></p><blockquote><p>A与B左外连接，并将（左边表）A中的所有数据存放的新表中，可以将字段分为A字段和B字段</p><p>只有实现条件A.key = B.key的元素B字段才有值，其余为null</p></blockquote></li><li><p><code>SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TABLEB B ON A.Key = B.Key WHERE B.Key IS NULL</code></p><blockquote><p>A与B左外连接，在之前的基础上通过判断语句<code>WHERE B.Key IS NULL</code>筛选出B字段为null的数据存放到新表中</p><p>总结：<strong>找出A中存在，但B中不存在的元素</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/LeftJoin.png"></p></li></ul></li><li><h5 id="Right-Outer-Join-—-右外连接（以连接右边的表作为查询基准）"><a href="#Right-Outer-Join-—-右外连接（以连接右边的表作为查询基准）" class="headerlink" title="Right Outer Join — 右外连接（以连接右边的表作为查询基准）"></a>Right Outer Join — 右外连接（以连接右边的表作为查询基准）</h5><ul><li><p><code>SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TABLEB B ON A.KEY = B.KEY</code></p><blockquote><p>A与B右外连接，并将（右边表）B中的所有数据存放的新表中，可以将字段分为A字段和B字段</p><p>只有实现条件A.key = B.key的元素A字段才有值，其余为null</p></blockquote></li><li><p><code>SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TABLEB B ON A.KEY = B.KEY WHERE A.KEY IS NULL</code></p><blockquote><p>查找出存在于B，但不存在于A的元素</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/RightJoin.png"></p></li></ul></li><li><h5 id="Full-Join-—-全连接（MySQL默认不支持Full-Join）"><a href="#Full-Join-—-全连接（MySQL默认不支持Full-Join）" class="headerlink" title="Full Join — 全连接（MySQL默认不支持Full Join）"></a>Full Join — 全连接（MySQL默认不支持Full Join）</h5><ul><li><p><code>SELECT &lt;select_list&gt; FROM TableA A OUTER JOIN TableB ON A.KEY = B.KEY</code></p><blockquote><p>合并A表跟B表</p></blockquote></li><li><p><code>SELECT &lt;select_list&gt; FROM TableA A OUTER JOIN TableB ON A.KEY = B.KEY WHERE A.KEY IS NULL OR B.KEY IS NULL</code></p><blockquote><p>合并A表跟B表的不重复部分（即将符合A.key = B.key的部分抽取出去）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/FULL-Join.png"></p></li><li><p>以上两种语句在Mysql中执行会报错，因为MySQL并不支持全连接的语法，解决方案:</p></li><li><p>UNION ALL联合左连接右连接进行查询</p></li><li><p><code>SELECT &lt;Aselect_list&gt; FROM TableA A LEFT JOIN TABLEB B ON A.key = B.key UNION ALL SELECT &lt;Bselect_list&gt; FROM TableA A RIGHT JOIN TABLEB B ON B.KEY = A.KEY </code></p><blockquote><p><Aselect_list>：A表的查询结果</p><p><Bselect_list>：B表的查询结果</p></blockquote></li></ul></li><li><h5 id="Cross-Join-—-交叉连接"><a href="#Cross-Join-—-交叉连接" class="headerlink" title="Cross Join — 交叉连接"></a>Cross Join — 交叉连接</h5><ul><li>又称为<strong>笛卡尔连接</strong>，<strong>将A与B两个表相乘 –&gt; A x B</strong>（若A有4条记录，B有5条记录，连接的新表就有20条记录）</li><li>特点：<strong>不需要 On 判断条件语句</strong></li><li><code>SELECT &lt;select_list&gt; FROM TableA CROSS JOIN Table B</code></li></ul></li><li><h5 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h5></li><li><h5 id="在多表联合操作时，使用join同时对某些数据进行更新操作"><a href="#在多表联合操作时，使用join同时对某些数据进行更新操作" class="headerlink" title="在多表联合操作时，使用join同时对某些数据进行更新操作"></a>在多表联合操作时，使用join同时对某些数据进行更新操作</h5></li><li><p>案例：修改A表和B表中具有相同字段的数据的某一字段值</p></li><li><p><code>UPDATE TableA A Join(SELECT a.key FROM TableA a INNER JOIN TableB b ON b.Key = a.key) B ON A.KEY = B.KEY SET A.value = &#39;new value&#39;</code></p><blockquote><p>a、b为原来的表，B为a、b经过join连接查询得到的结果</p><p>TableA A JOIN ()B：操作的表</p><p>value 为需要修改值</p><p>SELECT a.key FROM TableA a INNER JOIN TableB b ON b.Key = a.key ：利用 join 查询出表中相同字段的那个值，封装到新表 B中</p><p>A与B再通过ON从属语句判断出待修改数据，然后赋予新的值</p></blockquote></li><li><p><code>UPDATE TableA A inner join TableB B ON A.KEY = B.KEY SET A.VALUE=&#39;new value&#39;</code></p><blockquote><p>更加简便，省去了内部join连接查询修改值这一步</p></blockquote></li><li><h5 id="使用join优化子查询"><a href="#使用join优化子查询" class="headerlink" title="使用join优化子查询"></a>使用join优化子查询</h5></li><li><p>优化前：`</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select a.user_name , a.over , (select over from user2 where a.user_name = b,user_name) as over2</span><br><span class="line">from user1 a;</span><br></pre></td></tr></table></figure></li><li><p>优化后：</p></li><li><p><code>select a.user_name,a.over,b.over as over2 from user1 a left join user2 b on a.user_name = b.user_name</code></p><blockquote><p>解决了子查询中由于记录过多，由于对A表的每一条记录都要进行一次子查询而导致的查询效率低</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">MySQL-join概述</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized</title>
    <link href="http://example.com/2021/08/25/Synchronized/"/>
    <id>http://example.com/2021/08/25/Synchronized/</id>
    <published>2021-08-25T13:39:15.000Z</published>
    <updated>2021-09-17T19:36:41.775Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>多线程下操作数据难免发生线程安全问题，比如两个以上的线程同时写共享数据（临界资源）</p><p>Synchronized就是一种用于解决线程安全问题的<strong>同步锁</strong>，本质是一种悲观锁（互斥锁的实现），它可以保证共享资源在同一时刻只能被一个线程占用，其他线程只能等待资源被释放</p><h3 id="Synchronized的特征"><a href="#Synchronized的特征" class="headerlink" title="Synchronized的特征"></a>Synchronized的特征</h3><ul><li><p><strong>原子性</strong>：由synchronized关键字修饰的类或对象的所有操作都具有原子性</p><blockquote><p>具有原子性的操作不可再被拆分，既这些操作要么全部执行成功，要不就全部执行失败</p></blockquote></li><li><p><strong>可见性</strong>：多线程下，共享资源的状态、值信息对于其他所有线程都是可见的</p><ul><li>所有线程在访问由synchronized上锁的对象或类时，都需要获取它的锁，这个锁的状态以及具体对象或类中属性的状态对于其他线程都是可见的</li><li>占用锁的线程在释放锁之前会将修改过的变量值写回到主存中，保证主存中的共享资源永远是最新值</li></ul></li><li><p><strong>有序性</strong>：由synchronized加锁的类或对象，同时只能有一个线程访问同步代码块，也确定了线程执行同步代码块是按照获取锁的先后顺序，既保证程序执行的顺序按照编写好的代码执行</p><blockquote><p>Java允许编译器和处理器对指令进行重排序，会影响到多线程并发执行的顺序</p></blockquote></li><li><p><strong>可重入性</strong>：对于持有某个临界资源的线程，它可以再次请求这个自己持有锁的临界资源，是一种可重入锁</p></li></ul><h3 id="Synchronized的实现"><a href="#Synchronized的实现" class="headerlink" title="Synchronized的实现"></a>Synchronized的实现</h3><p>synchronized可以作用于静态方法、实例方法（成员函数）以及代码块上，在访问这些代码时，必须先获得对应的锁</p><ul><li><h5 id="当修饰于静态方法上时，是对类上锁，"><a href="#当修饰于静态方法上时，是对类上锁，" class="headerlink" title="当修饰于静态方法上时，是对类上锁，"></a>当修饰于静态方法上时，是对类上锁，</h5><ul><li>静态方法是在类加载时确定的，归类所有，不需要实例化就可以直接访问，</li></ul></li><li><h5 id="当修饰于实例方法上时，是对象实例上锁"><a href="#当修饰于实例方法上时，是对象实例上锁" class="headerlink" title="当修饰于实例方法上时，是对象实例上锁"></a>当修饰于实例方法上时，是对象实例上锁</h5><ul><li>成员函数归实例化对象所欲需要实例化后才能调用</li></ul></li><li><h5 id="当修饰于代码块时，根据传入的类型（类或实例）上锁"><a href="#当修饰于代码块时，根据传入的类型（类或实例）上锁" class="headerlink" title="当修饰于代码块时，根据传入的类型（类或实例）上锁"></a>当修饰于代码块时，根据传入的类型（类或实例）上锁</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">synTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        amount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(synTest.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock on class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock on instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><p>synchronized是基于设置在对象头中的monitor对象（锁）来实现的</p><ul><li>对象头主要是由<code>Mark Word</code>和<code>Class Metadata Address</code>构成的，而<code>MarkWord</code>中就存储了对象的锁信息，除此之外还有hashCode、分代年龄等重要信息</li><li>在Java虚拟机中，<code>monitor</code>也称为对象监视器，是由ObjectMonitor（基于C++）实现的，每一个对象都存在一个<code>monitor</code>与之关联，而每一个<code>monitor</code>对象又对应一个锁状态</li></ul><p>当线程尝试获取对象锁时，实际上是获取这个对象的<code>monitor</code>，当<code>monitor</code>被占用时就会处于锁定状态，使用synchronized实现同步的本质就是获取对象监视器<code>monitor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">//锁计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></p><p>ObjectMonitor中有两个队列 <code>_WaitSet</code>和<code>_EntryList</code>，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装ObjectWaiter对象)，<code>_owner</code>指向持有ObjectMonitor对象的线程</p><p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code> 集合，当线程获取到对象的monitor 后进入 <code>_Owner</code> 区域并把monitor中的<code>_owner</code>变量设置为当前线程同时monitor中的计数器<code>_count</code>加1，</p><p>若线程调用 wait() 方法，将释放当前持有的monitor，<code>_owner</code>变量恢复为null，<code>_count</code>自减1，同时该线程进入 <code>_WaitSet</code>集合中等待被唤醒。</p><p>若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p></blockquote><h3 id="synchronized锁的四种状态"><a href="#synchronized锁的四种状态" class="headerlink" title="synchronized锁的四种状态"></a>synchronized锁的四种状态</h3><blockquote><p>synchronized在jdk6时，迎来了一次较大的优化，新增了两种锁状态：轻量级锁和偏向锁、提供了锁消除、锁粗化、自旋锁等方法</p></blockquote><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>没有对资源进行加锁，所有线程都可以访问同一资源并进行修改，但这些线程中只有一个线程能修改成功</p><p>无锁是通过循环操作（自旋）来实现的。线程会不断的尝试修改资源，没有冲突就修改成功，将具体值写回内存，否则就会继续尝试修改</p><p>CAS(compare and swap)就是一种典型的无锁机制，它在每次写回数据时会先取出内存中的值，与当前线程期望的值作比较，只有比较值相同时，才将更新后的值写回到内存中，否则循环重复以上操作</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁针对不存在多线程竞争的共享资源，降低获取锁的代价</p><p>对于加了偏向锁的资源，会记录多次访问它的线程，当这个线程下次再访问这个资源时，可以自动获取锁</p><p>具体实现：</p><ul><li>当一个线程访问同步代码块并获取到偏向锁时，会在对象头的<code>Mark Word</code>中存储这个线程ID</li><li>这个线程下次再访问同步块时，不需要通过CAS操作来加锁和释放锁，只需要检测<code>Mark Word</code>中是否设置了指向当前线程的偏向锁，如果是则直接获取锁</li><li>如果不是，那么意味着发生了多线程竞争资源，那么会将偏向锁升级成轻量级锁，这个过程称为<strong>锁膨胀</strong></li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当其他线程获取锁失败时，不会进行阻塞，而是以自旋的形式，反复尝试获取锁，从而提高性能</p><blockquote><p>当线程获取锁失败时，被阻塞后需要等待其他线程唤醒或指定时间后才能重新进入就绪队列，等待CPU调度</p><p>这个过程需要操作系统切换CPU状态来完成，需要耗费一定的处理时间，</p><p>且如果同步代码块中的内容过于简单，获取锁所耗费的时间可能大于执行代码</p></blockquote><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>当多线程竞争达到三个线程以上的级别时，轻量级锁会升级为重量锁，锁对象的Mark Word存储的是指向重量级锁的指针，此时竞争锁失败的线程都会进入阻塞状态。</p><p>jdk6之前的synchronized默认采用的就是重量级锁</p><h4 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h4><p>线程获取轻量级锁失败后，会通过自旋的方式让线程反复申请锁</p><p>自旋锁就是这种方式的实现，适用于大多数共享资源占用时间不长的情况，切换线程带来的资源消耗不值得，因此选择让线程循环，等待锁释放。</p><p>但如果锁被其他线程长时间占用，那么等待线程会一直处在自旋的阶段，带来一定的性能开销</p><p>为了解决这个问题，又提出了自适应自旋锁，自旋的次数不再固定，而是由申请这个锁对象的上一个线程的自旋次数以及锁的当前拥有者的状态来决定</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/75880892">https://zhuanlan.zhihu.com/p/75880892</a></p>]]></content>
    
    
    <summary type="html">Synchronized关键字解析</summary>
    
    
    
    
    <category term="Java并发" scheme="http://example.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java中几种重要的锁</title>
    <link href="http://example.com/2021/08/22/Java%E9%94%81/"/>
    <id>http://example.com/2021/08/22/Java%E9%94%81/</id>
    <published>2021-08-22T14:08:50.000Z</published>
    <updated>2021-09-17T19:37:17.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中提供了多种锁机制，根据锁的不同特性可以适应于不同的并发业务场景,本文主要简要讲解目前主流锁的分类和基本概念</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>乐观锁就如它的定义，以乐观的态度去进行数据的读写。在并发操作时，认为不会发生并发冲突问题，因此<strong>不会对资源进行加锁</strong>，<strong>只会在更新数据时检查数据是否被其他线程修改过</strong>，如果数据没有被更新，那么当前线程就将修改过的值写回，否则不写入（报错或重试）</p><p>乐观锁在Java中是通过无锁编程实现的，常见的无锁编程机制就有<strong>CAS自旋</strong></p><p>悲观锁则认为每次进行数据的读写都会发生并发冲突问题，因此<strong>每次在使用资源前都会对资源进行上锁</strong>，以<strong>确保数据在读写过程中不会被其他线程干扰</strong>。</p><p>Synchronized关键字和Lock的实现类都是悲观锁</p><p>根据乐观锁和悲观锁的特性：</p><ul><li><strong>乐观锁适用于读操作多的场景</strong>，不同线程进行读操作不会发生冲突问题，通过乐观锁的无锁机制可以降低对资源上锁带来的消耗，提高性能</li><li>悲观锁适用于写操作多的场景，加锁可以保证并发写下数据的正确性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 悲观锁的实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized关键字修饰于实例方法，在进入代码块前，必须先获得对应的对象实例的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        amount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReetrantLock可重入锁，在访问共享资源前，必须先获得定义的锁lock</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        amount++;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观锁的实现</span></span><br><span class="line"><span class="comment">// 原子类AtomicInteger的自增方法采用自旋CAS操作来操作共享资源</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    atomicInteger.incrementAndGet();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 底层会调用unsafe类的compareAndSetInt(o, offset, expected, x)</span></span><br><span class="line"><span class="comment">// 该方法三个重要参数：</span></span><br><span class="line"><span class="comment">//offset：内存偏移量，可以理解为变量在内存中具体的值</span></span><br><span class="line"><span class="comment">//expected：线程所期望变量当前的值</span></span><br><span class="line"><span class="comment">//x：变量更新后的值</span></span><br><span class="line"><span class="comment">// 当且仅当offset == expected时，更新才成功，否则自旋</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h3><p><strong>自旋锁本质就是一种乐观锁</strong>，它是无锁机制的实现，当某个线程在访问资源失败时，系统不会阻塞该线程，反而让线程在申请获取锁这一层面自旋，即循环申请，实现原理就是我们熟知的CAS</p><p>自旋锁虽然可以减少阻塞线程所带来的CPU时间消耗，但如果某个线程一直无法获取到资源，那么它会一直自旋直到获取到资源对应锁，这个自旋的线程也会浪费一定的CPU资源,为了解决这个问题，衍生出了自适应自旋锁</p><p><strong>自适应自旋锁就是自旋次数不固定的自旋锁</strong>，它的自旋次数依赖于上次获取这个锁的线程所进行的自旋次数以及当前占有锁的线程状态来决定</p><h3 id="synchronized的四种锁状态：无锁、偏向锁、轻量级锁、重量级锁"><a href="#synchronized的四种锁状态：无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="synchronized的四种锁状态：无锁、偏向锁、轻量级锁、重量级锁"></a>synchronized的四种锁状态：无锁、偏向锁、轻量级锁、重量级锁</h3><p>synchronized实现线程同步是基于存储在对象头<code>Mark Word</code>中的<code>monitor</code>对象（锁标志位）来实现的</p><p>Java中所有对象的对象头中都设置了monitor对象，因此每一个Java对象都可以当成一个锁</p><p>每一个线程都有一个可用的<code>monitor record</code>列表，也称作锁列表,用于存放已获取资源的对象头的<code>Mark Word </code>信息</p><p>当某个对象（资源）的monitor对象被线程占用时，会自动进入锁定状态，这个对象的<code>monitor</code>中有一个<code>Owner</code>字段会<strong>存放拥有该锁的线程的唯一标识</strong>（PID），其他线程无法再获取同一个monitor对象</p><p>synchronized一共有四种锁状态，级别从低到高分别是：无锁、偏向锁、轻量级锁、重量级锁</p><p>锁状态会随着并发线程动态升级，这个过程称为<strong>锁膨胀</strong>，锁状态只能升级不能降级</p><h5 id="无锁状态：不对资源进行加锁，所有线程都可以访问并修改同一资源，即所有线程都能获取这个资源的锁，但只有一个线程能修改成功，修改失败的线程会通过循环代码，尝试修改直至成功或放弃"><a href="#无锁状态：不对资源进行加锁，所有线程都可以访问并修改同一资源，即所有线程都能获取这个资源的锁，但只有一个线程能修改成功，修改失败的线程会通过循环代码，尝试修改直至成功或放弃" class="headerlink" title="无锁状态：不对资源进行加锁，所有线程都可以访问并修改同一资源，即所有线程都能获取这个资源的锁，但只有一个线程能修改成功，修改失败的线程会通过循环代码，尝试修改直至成功或放弃"></a>无锁状态：不对资源进行加锁，所有线程都可以访问并修改同一资源，即所有线程都能获取这个资源的锁，但只有一个线程能修改成功，修改失败的线程会通过循环代码，尝试修改直至成功或放弃</h5><ul><li>前面提到的自旋CAS就是一种典型无锁状态</li><li>无锁在读操作比较多、写操作比较少的并发场景下会很高效，因为节省了获取锁带来的性能开销</li></ul><h5 id="偏向锁：偏向锁针对于不存在多线程竞争的情况，对于某个经常访问同一资源的线程，偏向锁会记录这个线程的唯一标识，当这个线程下次再访问同一资源时，不需要对资源上锁或者通过CAS操作获取资源，只需要判断资源的对象头中是否设置了指向当前线程的偏向锁，即可以直接获取资源"><a href="#偏向锁：偏向锁针对于不存在多线程竞争的情况，对于某个经常访问同一资源的线程，偏向锁会记录这个线程的唯一标识，当这个线程下次再访问同一资源时，不需要对资源上锁或者通过CAS操作获取资源，只需要判断资源的对象头中是否设置了指向当前线程的偏向锁，即可以直接获取资源" class="headerlink" title="偏向锁：偏向锁针对于不存在多线程竞争的情况，对于某个经常访问同一资源的线程，偏向锁会记录这个线程的唯一标识，当这个线程下次再访问同一资源时，不需要对资源上锁或者通过CAS操作获取资源，只需要判断资源的对象头中是否设置了指向当前线程的偏向锁，即可以直接获取资源"></a>偏向锁：偏向锁针对于不存在多线程竞争的情况，对于某个经常访问同一资源的线程，偏向锁会记录这个线程的唯一标识，当这个线程下次再访问同一资源时，不需要对资源上锁或者通过CAS操作获取资源，只需要判断资源的对象头中是否设置了指向当前线程的偏向锁，即可以直接获取资源</h5><ul><li>偏向锁的具体实现是在对象头的<code>Mark Word</code>中存储锁偏向的线程ID</li><li>偏向锁的目的就是为了在没有线程竞争的情况下减少不必要的因获取资源或者对资源上锁带来的消耗</li><li>持有偏向锁的线程使用完了资源，也不会释放锁。当存在其他线程尝试获取已经设置了偏向线程的偏向锁时，线程才会释放锁（前提是资源已经使用完成），线程释放掉偏向锁后，会根据当前并发情况升级为轻量级锁</li></ul><h5 id="轻量级锁：针对竞争线程数量不多的情况，通过CAS获取资源的锁，获取锁失败的线程会通过自旋的方式等待锁释放"><a href="#轻量级锁：针对竞争线程数量不多的情况，通过CAS获取资源的锁，获取锁失败的线程会通过自旋的方式等待锁释放" class="headerlink" title="轻量级锁：针对竞争线程数量不多的情况，通过CAS获取资源的锁，获取锁失败的线程会通过自旋的方式等待锁释放"></a>轻量级锁：针对竞争线程数量不多的情况，通过CAS获取资源的锁，获取锁失败的线程会通过自旋的方式等待锁释放</h5><ul><li>当线程访问某个同步代码块时，如果此时同步对象头中设置的锁状态为无锁，JVM会在当前线程的栈帧中创建一个名为锁记录的空间，用于存储对象的<code>Mark Word</code>的拷贝,并将资源对象头的<code>Mark Word</code>拷贝到锁记录中</li><li>JVM使用CAS操作尝试将资源对象的<code>Mark Word</code>更新为指向锁记录的指针，并将锁记录里的owner指针指向对象的<code>Mark Word</code>，成功后当前线程就拥有了该资源独享的锁</li><li>如果轻量级锁的更新操作失败了，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧中的锁记录<ul><li>如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行</li><li>否则说明多个线程竞争锁</li></ul></li><li>当等待线程的自旋次数超过一定次数，或者有第三个线程加入了竞争锁队列，轻量级锁会升级为重量级锁</li></ul><h5 id="重量级锁：等待锁释放的线程都会被系统阻塞，进入阻塞状态，这个过程耗费CPU状态切换所需相关的资源"><a href="#重量级锁：等待锁释放的线程都会被系统阻塞，进入阻塞状态，这个过程耗费CPU状态切换所需相关的资源" class="headerlink" title="重量级锁：等待锁释放的线程都会被系统阻塞，进入阻塞状态，这个过程耗费CPU状态切换所需相关的资源"></a>重量级锁：等待锁释放的线程都会被系统阻塞，进入阻塞状态，这个过程耗费CPU状态切换所需相关的资源</h5><p>四种锁状态在对象头中<code>Mark Word</code>中对应的锁标志位</p><table><thead><tr><th align="center">无锁</th><th align="center">01</th></tr></thead><tbody><tr><td align="center"><strong>偏向锁</strong></td><td align="center"><strong>01</strong></td></tr><tr><td align="center"><strong>轻量级锁</strong></td><td align="center"><strong>00</strong></td></tr><tr><td align="center"><strong>重量级锁</strong></td><td align="center"><strong>10</strong></td></tr></tbody></table><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><h5 id="公平锁：多线程下，所有申请同一资源的线程按照申请锁的顺序排成一个队列，该队列使用双向链表的数据结构，在队列头部的资源才可以申请访问资源，其余线程均进入等待状态阻塞，等待其前一个有效线程唤醒，新加入竞争锁队列的线程默认添加到队列尾部"><a href="#公平锁：多线程下，所有申请同一资源的线程按照申请锁的顺序排成一个队列，该队列使用双向链表的数据结构，在队列头部的资源才可以申请访问资源，其余线程均进入等待状态阻塞，等待其前一个有效线程唤醒，新加入竞争锁队列的线程默认添加到队列尾部" class="headerlink" title="公平锁：多线程下，所有申请同一资源的线程按照申请锁的顺序排成一个队列，该队列使用双向链表的数据结构，在队列头部的资源才可以申请访问资源，其余线程均进入等待状态阻塞，等待其前一个有效线程唤醒，新加入竞争锁队列的线程默认添加到队列尾部"></a>公平锁：多线程下，所有申请同一资源的线程按照申请锁的顺序排成一个队列，该队列使用双向链表的数据结构，在队列头部的资源才可以申请访问资源，其余线程均进入等待状态阻塞，等待其前一个有效线程唤醒，新加入竞争锁队列的线程默认添加到队列尾部</h5><h5 id="非公平锁：多线程下竞争锁，直接尝试获取锁，获取失败的线程进入等待队列。申请锁和获取到锁之间没有顺序性，即可能出现后申请锁的线程优先争取到锁"><a href="#非公平锁：多线程下竞争锁，直接尝试获取锁，获取失败的线程进入等待队列。申请锁和获取到锁之间没有顺序性，即可能出现后申请锁的线程优先争取到锁" class="headerlink" title="非公平锁：多线程下竞争锁，直接尝试获取锁，获取失败的线程进入等待队列。申请锁和获取到锁之间没有顺序性，即可能出现后申请锁的线程优先争取到锁"></a>非公平锁：多线程下竞争锁，直接尝试获取锁，获取失败的线程进入等待队列。申请锁和获取到锁之间没有顺序性，即可能出现后申请锁的线程优先争取到锁</h5><h5 id="公平锁与非公平锁的优缺点对比："><a href="#公平锁与非公平锁的优缺点对比：" class="headerlink" title="公平锁与非公平锁的优缺点对比："></a>公平锁与非公平锁的优缺点对比：</h5><p>公平锁可以保证处在有效等待中的线程最终都可以获取到锁，但由于每次锁释放后都需要进行线程唤醒，需要耗费额外的CPU资源</p><p>非公平锁可以减少唤醒线程带来的开销，整体吞吐率要比公平锁高，但由于抢占式锁的机制，可能会存在某些线程一直无法获取到资源</p><h5 id="底层实现：以ReentrankLock为例，ReentrantLock中提供了公平锁和非公平锁的实现方法，默认采用非公平锁"><a href="#底层实现：以ReentrankLock为例，ReentrantLock中提供了公平锁和非公平锁的实现方法，默认采用非公平锁" class="headerlink" title="底层实现：以ReentrankLock为例，ReentrantLock中提供了公平锁和非公平锁的实现方法，默认采用非公平锁"></a>底层实现：以ReentrankLock为例，ReentrantLock中提供了公平锁和非公平锁的实现方法，默认采用非公平锁</h5><ul><li><p>获取公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取公平锁与非公锁的唯一区别：hasQueuedPredecessors</span></span><br><span class="line">              <span class="comment">// 通过该方法可以保证同步队列获取锁的顺序性</span></span><br><span class="line">              <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ....</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 该方法判断当前线程是否位于同步队列中的第一个，也就是链表表头head</span></span><br><span class="line"><span class="comment">// 如果是，返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Node h, s;</span><br><span class="line">      <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((s = h.next) == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              s = <span class="keyword">null</span>; <span class="comment">// traverse in case of concurrent cancellation</span></span><br><span class="line">              <span class="keyword">for</span> (Node p = tail; p != h &amp;&amp; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                      s = p;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s.thread != Thread.currentThread())</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>获取非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 不需要判断当前线程是否为同步队列的第一位，直接CAS操作尝试获取锁</span></span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ....</span><br></pre></td></tr></table></figure></li></ul><h3 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h3><h5 id="可重入锁：获取到锁的线程可以再次获取它拥有的同一把锁（由Synchronized修饰的实例方法内部可以调用同一个类中定义的另一个由Synchronized修饰的实例方法），释放锁时也必须释放同等数量的锁"><a href="#可重入锁：获取到锁的线程可以再次获取它拥有的同一把锁（由Synchronized修饰的实例方法内部可以调用同一个类中定义的另一个由Synchronized修饰的实例方法），释放锁时也必须释放同等数量的锁" class="headerlink" title="可重入锁：获取到锁的线程可以再次获取它拥有的同一把锁（由Synchronized修饰的实例方法内部可以调用同一个类中定义的另一个由Synchronized修饰的实例方法），释放锁时也必须释放同等数量的锁"></a>可重入锁：获取到锁的线程可以再次获取它拥有的同一把锁（由Synchronized修饰的实例方法内部可以调用同一个类中定义的另一个由Synchronized修饰的实例方法），释放锁时也必须释放同等数量的锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        amount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>synchronized和ReentrantLock都是常见的可重入锁</li><li>可重入的实现：可重入锁ReetrantLock获取锁方法（ReetrantLock默认采用非公平锁）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">          <span class="comment">// 获取当前资源的state</span></span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="comment">// 如果state为0，说明当前锁没有被占用</span></span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 通过CAS操作尝试获取锁</span></span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  <span class="comment">// 成功获取到锁，将锁的Owner设置为当前线程</span></span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果锁的Owner是当前线程，那么对state进行累加，即锁的重入</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">              <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="不可重入锁：已经拥有一个锁的线程必须释放掉已有的锁才能再去申请锁（即使是同一把锁）"><a href="#不可重入锁：已经拥有一个锁的线程必须释放掉已有的锁才能再去申请锁（即使是同一把锁）" class="headerlink" title="不可重入锁：已经拥有一个锁的线程必须释放掉已有的锁才能再去申请锁（即使是同一把锁）"></a>不可重入锁：已经拥有一个锁的线程必须释放掉已有的锁才能再去申请锁（即使是同一把锁）</h5><h3 id="独享锁与共享锁"><a href="#独享锁与共享锁" class="headerlink" title="独享锁与共享锁"></a>独享锁与共享锁</h3><h5 id="独享锁，通常也叫排他锁、写锁：该锁只能被一个线程占用，其他线程不能在对资源加锁，拥有某个资源的独享锁的线程可以对资源进行读写操作"><a href="#独享锁，通常也叫排他锁、写锁：该锁只能被一个线程占用，其他线程不能在对资源加锁，拥有某个资源的独享锁的线程可以对资源进行读写操作" class="headerlink" title="独享锁，通常也叫排他锁、写锁：该锁只能被一个线程占用，其他线程不能在对资源加锁，拥有某个资源的独享锁的线程可以对资源进行读写操作"></a>独享锁，通常也叫排他锁、写锁：该锁只能被一个线程占用，其他线程不能在对资源加锁，拥有某个资源的独享锁的线程可以对资源进行读写操作</h5><h5 id="共享锁，通常也叫做读锁：该锁可以被多个线程持有，即多线程下，不同线程可以对同一资源加上多个共享锁，具有共享锁的线程只能对资源进行读，不能写，其他线程也不能再加上独享锁，直到资源上的所有共享锁都被释放"><a href="#共享锁，通常也叫做读锁：该锁可以被多个线程持有，即多线程下，不同线程可以对同一资源加上多个共享锁，具有共享锁的线程只能对资源进行读，不能写，其他线程也不能再加上独享锁，直到资源上的所有共享锁都被释放" class="headerlink" title="共享锁，通常也叫做读锁：该锁可以被多个线程持有，即多线程下，不同线程可以对同一资源加上多个共享锁，具有共享锁的线程只能对资源进行读，不能写，其他线程也不能再加上独享锁，直到资源上的所有共享锁都被释放"></a>共享锁，通常也叫做读锁：该锁可以被多个线程持有，即多线程下，不同线程可以对同一资源加上多个共享锁，具有共享锁的线程只能对资源进行读，不能写，其他线程也不能再加上独享锁，直到资源上的所有共享锁都被释放</h5><blockquote><p>多线程下，并发读不会引发数据冲突问题，只有并发写和并发读写存在冲突问题</p></blockquote><p>Java中提供了一种读写锁 <code>ReentrantReadWirteLock</code>同时具备独享锁和共享锁的功能</p><p>ReentrantReadWriteLock中关于ReadLock和WriteLock的声明</p><p>不难看出，ReentrantReadWriteLock中，读锁和写锁实际都是Sync锁，即AQS框架下的一个子类锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">   <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">   <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line">       ....</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line">       ....</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock中读写锁的之间的加锁操作是分离的，因此在通过ReentrantReadWriteLock对资源加锁时，会将这个资源的state字段根据int型32位拆分为高低16位分别表示读锁与写锁的状态</p><ul><li>state值的低16位表示当前写锁状态</li><li>state值的高16位表示当前读锁状态</li></ul><h5 id="底层分析：获取独享锁"><a href="#底层分析：获取独享锁" class="headerlink" title="底层分析：获取独享锁"></a>底层分析：获取独享锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="comment">// 获取state值低16位，即写锁的状态（个数）</span></span><br><span class="line">           <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// c!=0,即资源当前已被线程上锁</span></span><br><span class="line">               <span class="comment">// w == 0表示线程当前给资源上的锁不是独享锁，不能在添加独享锁，返回false</span></span><br><span class="line">               <span class="comment">// w == 0为false，意味着当前已经有线程给资源添加了写锁，如果current不是上锁的线程，则 // 不能在添加独享锁，返回false</span></span><br><span class="line">               <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">// 如果写入锁的数量大于最大数，抛出错误</span></span><br><span class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">               <span class="comment">// 当前线程是给资源添加独享锁的线程，重入锁</span></span><br><span class="line">               setState(c + acquires);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 资源当前空闲，CAS尝试获取锁</span></span><br><span class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">               !compareAndSetState(c, c + acquires))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           setExclusiveOwnerThread(current);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// state值与其state低16位进行与运算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><h5 id="获取共享锁："><a href="#获取共享锁：" class="headerlink" title="获取共享锁："></a>获取共享锁：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">          Thread current = Thread.currentThread();</span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="comment">// exclusiveCount(c) != 0表示其他线程已经对资源添加了独享锁，直接返回-1，表示无法添加读锁</span></span><br><span class="line">          <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">              getExclusiveOwnerThread() != current)</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 获取当前共享锁的状态（个数）</span></span><br><span class="line">          <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">          <span class="comment">// 如果共享锁没有超出最大锁个数，CAS操作尝试获取共享锁</span></span><br><span class="line">          <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">              r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">              compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 共享锁个数为0，即当前线程第一个给资源添加共享锁，共享锁数量+1</span></span><br><span class="line">                  firstReader = current;</span><br><span class="line">                  firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">              <span class="comment">// 资源已经被添加了共享锁，且当前线程就是第一个为资源添加共享锁的线程，共享锁数量+1</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                  firstReaderHoldCount++;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                  <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">                      rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                      cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                      readHolds.set(rh);</span><br><span class="line">                  rh.count++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/jyroy/p/11365935.html">https://www.cnblogs.com/jyroy/p/11365935.html</a></p>]]></content>
    
    
    <summary type="html">关于Java锁</summary>
    
    
    
    
    <category term="Java并发" scheme="http://example.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(Singleton)</title>
    <link href="http://example.com/2021/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89/"/>
    <id>http://example.com/2021/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89/</id>
    <published>2021-08-20T13:39:15.000Z</published>
    <updated>2021-09-17T18:38:34.531Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="设计模式一：单例模式（Singleton）"><a href="#设计模式一：单例模式（Singleton）" class="headerlink" title="设计模式一：单例模式（Singleton）"></a>设计模式一：单例模式（Singleton）</h2><h4 id="何为单例模式（Singleton）？"><a href="#何为单例模式（Singleton）？" class="headerlink" title="何为单例模式（Singleton）？"></a>何为单例模式（Singleton）？</h4><p>单例模式是一种典型的设计模式，<strong>使用单例模式设计的类，只允许拥有一个类实例</strong></p><h4 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h4><ol><li><strong>整个系统只需要拥有一个全局对象</strong>：比如SpringBoot中对应场景功能的配置类，它将所有相关配置信息集成到一个类中，并由一个对象实例统一读取。程序中其他对象就可以通过这个单例对象获取配置信息</li><li><strong>网站的计数器</strong>：用于记录网页访问量的单例对象，每当网页被用户访问一次，就对这个单例对象进行累加。</li><li><strong>应用程序的日志</strong></li></ol><h4 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h4><p>单例模式的实现核心：私有化构造方法</p><p>主要可以划分为两种方式：</p><h5 id="饿汉式单例模式：在类加载时就将对象实例创建"><a href="#饿汉式单例模式：在类加载时就将对象实例创建" class="headerlink" title="饿汉式单例模式：在类加载时就将对象实例创建"></a>饿汉式单例模式：在类加载时就将对象实例创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singletonHungry</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将类实例声明为静态成员，并完成实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singletonHungry = <span class="keyword">new</span> singletonHungry();</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singletonHungry</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 提供公开的方法用于返回单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singletonHungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonHungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式优点：实现简单，在类加载时就完成了实例化，避免线程同步问题</p><p>缺点：由于类加载时就完成实例化，即分配了内存空间，如果这个单例对象一直未被使用，可能会造成内存浪费</p><h5 id="懒汉式单例模式：懒加载（Lazy-Loading）的应用，在需要使用时才完成对象的实例化"><a href="#懒汉式单例模式：懒加载（Lazy-Loading）的应用，在需要使用时才完成对象的实例化" class="headerlink" title="懒汉式单例模式：懒加载（Lazy Loading）的应用，在需要使用时才完成对象的实例化"></a>懒汉式单例模式：懒加载（Lazy Loading）的应用，在需要使用时才完成对象的实例化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singletonLazy</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singletonLazy;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singletonLazy</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singletonLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当对象为空时，即还未完成实例化时，再去做实例化操作并返回</span></span><br><span class="line">        <span class="keyword">if</span>(singletonLazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singletonLazy = <span class="keyword">new</span> singletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonLazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式优点：应用到了懒加载，即在真正使用时才去实例化，可以有效节省内存空间</p><p>以上懒汉式单例模式只适用于单线程场景下，多线程操作同一个单例对象，如果同时访问到getInstance方法，可能会产生多个实例，因此需要对方法进行加锁</p><h5 id="双重检测加锁懒汉式"><a href="#双重检测加锁懒汉式" class="headerlink" title="双重检测加锁懒汉式"></a>双重检测加锁懒汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singletonLazy</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用volatile关键字保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> singletonLazy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singletonLazy</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singletonLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singletonLazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 使用synchronized对类进行加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(singletonLazy.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singletonLazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singletonLazy = <span class="keyword">new</span> singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonLazy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过加锁以及双重检测 if(singletonLazy == null)可以有效保证多线程下的单例对象只实例化一次</p><blockquote><p>但如果有黑客通过反射来实例化对象，可以绕开getInstance()方法，通过反射执行私有化的构造方法来得到除单例对象外的其他对象实例</p><p>可以通过对构造方法进行加锁以及抛出异常来防止</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singletonLazy</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singletonLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (singletonLazy.class)&#123;</span><br><span class="line">            <span class="comment">// 第一次使用到这个单例对象时，会进入私有构造方法进行实例化，并将flag设置为true</span></span><br><span class="line">            <span class="comment">// 在这之后如果有用户通过反射调用构造方法，会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;无法构造&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singletonLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singletonLazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 使用synchronized对类进行加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(singletonLazy.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singletonLazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singletonLazy = <span class="keyword">new</span> singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonLazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><h5 id="单例模式的优点："><a href="#单例模式的优点：" class="headerlink" title="单例模式的优点："></a>单例模式的优点：</h5><ol><li>在内存中只存在一个对象实例，节省内存空间</li><li>避免频繁的创建销毁对象实例</li><li>为整个系统提供一个全局访问点</li></ol><h5 id="单例模式的缺点："><a href="#单例模式的缺点：" class="headerlink" title="单例模式的缺点："></a>单例模式的缺点：</h5><ol><li>不适用于频繁变化的对象</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出</li><li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失</li></ol>]]></content>
    
    
    <summary type="html">关于单例模式</summary>
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://example.com/2021/08/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/08/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-08-15T13:39:15.000Z</published>
    <updated>2021-09-17T19:09:34.768Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring AOP 基于代理模式实现，那么何为代理模式？</p><h2 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h2><p>代理模式的官方定义是：为其他对象提供一种代理以控制对这个对象的访问，简单来说就是<strong>提供了对目标对象另外的访问方式：通过代理对象访问目标对象</strong></p><blockquote><p>有一种情况：A类对象不想或者不能直接引用另一个B类对象，那么此时就需要代理模式</p><p>使用了代理之后，A类不直接去操作B类，而是通过B类的代理类C去操作</p><p>代理对象可以在这两个对象之间起到中介的作用</p></blockquote><p>代理模式的思想是为了提供额外的处理胡总和不同的操作而在实际对象与调用者之前插入一个代理对象</p><p>代理模式的好处：在目标对象实现的基础上，增加额外的功能</p><h5 id="Java中的代理模式一共有三种：静态代理，JDK动态代理，CGlib动态代理"><a href="#Java中的代理模式一共有三种：静态代理，JDK动态代理，CGlib动态代理" class="headerlink" title="Java中的代理模式一共有三种：静态代理，JDK动态代理，CGlib动态代理"></a>Java中的代理模式一共有三种：静态代理，JDK动态代理，CGlib动态代理</h5><h5 id="代理模式一般涉及4个角色："><a href="#代理模式一般涉及4个角色：" class="headerlink" title="代理模式一般涉及4个角色："></a>代理模式一般涉及4个角色：</h5><ul><li><p>InterfaceSubject：接口，是被访问者或者说被访问资源的抽象</p></li><li><p>SubjectImpl：接口实现类，是被访问者或者被访问资源的实现类，也是被代理对象</p></li><li><p>SubjectProxy：被访问者或者被访问资源的代理实现类，该类持有一个InterfaceSubject接口的实例</p></li><li><p>Client：代表访问者的抽象角色</p><blockquote><p>Client将会访问InterfaceSubject类型的对象或者资源</p><p>在这个情景中，Client无法直接访问到InterfaceSubject资源，而是通过代理类SubjectProxy去实现</p></blockquote></li></ul><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>实现方式：被代理对象和代理对象实现同一个接口或是继承相同父类，通过调用代理对象的同名方法来调用被代理对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现：目标对象（被代理对象）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">&quot;target&quot;</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现：代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接受构造方法传入的目标对象，保存到代理对象中</span></span><br><span class="line">    <span class="comment">// 即代理对象中需要一个接口的实例</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao targetDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao iuserDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDao = iuserDao;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;proxy -- before target&quot;</span>);</span><br><span class="line">        targetDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;proxy -- after target&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="comment">// 将目标对象传入代理对象，建立代理关系</span></span><br><span class="line">        UserDaoProxy proxy = <span class="keyword">new</span> UserDaoProxy(target);</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态代理总结："><a href="#静态代理总结：" class="headerlink" title="静态代理总结："></a>静态代理总结：</h5><ul><li>优点：可以在不修改被代理对象目标方法代码的前提下，对方法进行扩展</li><li>缺点：静态代理需要代理对象实现与目标对象一样的接口，所以可能会生成很多代理类，一旦接口增加新方法，目标对象和代理对象都要重新维护</li></ul><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>实现方式：</p><ul><li>代理对象不需要实现目标对象所实现的接口，但需要指定目标对象实现的接口的类型</li><li>代理对象利用JDK提供的API 生成，动态地在内存中构建地代理对象</li></ul><h5 id="JDK动态代理用于生成代理的核心API-位于-java-lang-reflect-Proxy-包下的-newProxyInstance"><a href="#JDK动态代理用于生成代理的核心API-位于-java-lang-reflect-Proxy-包下的-newProxyInstance" class="headerlink" title="JDK动态代理用于生成代理的核心API: 位于 java.lang.reflect.Proxy 包下的 newProxyInstance"></a>JDK动态代理用于生成代理的核心API: 位于 java.lang.reflect.Proxy 包下的 newProxyInstance</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 三个参数分别是：</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 1. ClassLoader loader：目标对象使用的类加载器，获取类加载器的方法是固定的</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 2. Class&lt;?&gt;[] interfaces：目标对象实现的所有接口的类型，使用泛型方式确定</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 3. InvocationHandler h：事件处理，执行目标对象的方法时，会触发该事件处理器的方法，把当前执行   目标对象的方法作为参数传入</span></span></span><br><span class="line"><span class="function">    <span class="comment">// InvocationHandler是一个接口，也是JDK动态代理的核心之一，需要自定义实现类去实现它，内部定义的方法逻辑就是动态代理后的逻辑</span></span></span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 目标功能逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态代理工厂</span></span><br><span class="line"><span class="comment">// 不需要实现接口，但需要指定接口类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">// 维护接口的实例 -- 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成目标对象的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="comment">// 内部类实现InvocationHandler</span></span><br><span class="line">            <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span> </span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;before 事务&quot;</span>)</span><br><span class="line">                    Object returnValues = method.invoke(target,args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;after 事务&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> returnValues;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        IUserDao proxy = <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理总结：</p><ul><li>代理对象不需要实现接口，但<strong>目标对象一定要实现接口，否则不能使用动态代理</strong></li></ul><h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>CGLib动态代理是一个<strong>第三方实现的动态代理类库</strong>，不要求目标对象必须实现接口，它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)</p><p>CGLib代理，也叫做子类代理，<strong>它是在内存中构建目标对象的一个子类对象从而实现对目标功能的扩展</strong></p><p>实现方式：</p><ol><li>需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能</li><li>引入功能包后,就可以在内存中动态构建子类</li><li>代理的类不能为final,否则报错</li><li>目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法</li><li>如果方法为static,private则无法进行代理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 委托类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 代理方法的MethodProxy对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, </span></span></span><br><span class="line"><span class="params"><span class="function">                            Method method, </span></span></span><br><span class="line"><span class="params"><span class="function">                            Object[] objects, </span></span></span><br><span class="line"><span class="params"><span class="function">                            MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务开始......&quot;</span> + method.getName());</span><br><span class="line">        Object o1 = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;事务结束.......&quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.cnblogs.com/qlqwjy/p/7550609.html">https://www.cnblogs.com/qlqwjy/p/7550609.html</a></p>]]></content>
    
    
    <summary type="html">代理模式的使用</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://example.com/2021/08/10/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/08/10/MySQL%E7%B4%A2%E5%BC%95/</id>
    <published>2021-08-10T13:39:15.000Z</published>
    <updated>2021-09-17T19:01:28.092Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><ul><li><h4 id="何为索引？"><a href="#何为索引？" class="headerlink" title="何为索引？"></a>何为索引？</h4><ul><li>一种<strong>帮助mysql提高查询效率的数据结构</strong></li><li>索引的优点：加快数据查询速度</li><li>索引的缺点：<ul><li>维护索引需要耗费数据库资源</li><li>索引需要占用磁盘空间</li><li>当对表的数据进行增删改的时候，需要维护索引（重排序），会降低效率</li></ul></li></ul></li><li><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><ul><li><p><strong>主键索引</strong>：将某个列设定为<strong>主键</strong>后，数据库会<strong>自动建立索引</strong>，在InnoDB引擎中又称为聚簇索引</p></li><li><p><strong>单值索引/普通索引</strong>：一个单值索引只能包含一个列，<strong>一个表中可以有多个单值索引</strong></p></li><li><p><strong>唯一索引</strong>：索引列的值必须唯一，但允许有且仅有一个空值null</p><blockquote><p>与主键索引的异同在于，主键索引和唯一索引的值都必须唯一，即在表中只能有一个</p><p>但主键索引不允许有空值null（主键不能为null），但唯一索引可以有一个空值</p></blockquote></li><li><p><strong>复合索引</strong>：一个索引包含多个列</p></li><li><p>全文索引Full Text（MySQL5.7版本之前，只能用于MyISAM引擎）</p></li></ul></li><li><h4 id="MySQL索引使用的数据结构主要有-BTree索引-和-哈希索引"><a href="#MySQL索引使用的数据结构主要有-BTree索引-和-哈希索引" class="headerlink" title="MySQL索引使用的数据结构主要有 BTree索引 和 哈希索引"></a>MySQL索引使用的数据结构主要有 BTree索引 和 哈希索引</h4><blockquote><p>Btree索引使用的是 B树种的 B+Tree</p><p>哈希索引底层数据结构就是哈希表</p><p>在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快</p><p>其他大部分场景，一般使用BTree索引</p></blockquote></li><li><h4 id="索引的底层原理"><a href="#索引的底层原理" class="headerlink" title="==索引的底层原理=="></a>==索引的底层原理==</h4><blockquote><p>MySQL通过InnoDB存储数据，<strong>每个数据包含主键值（key）、数据值（data）以及指向下一个数据的指针</strong>，会<strong>先将数据根据主键值进行排序</strong>，然后将所有数据通过指针链接起来形成一个链表</p><p>MySQL<strong>采用B+Tree结构和分页存储形式</strong>，就是<strong>将链表中的数据存储到若干个固定大小的页</strong>（在InnoDB中页的默认容量为16KB），<strong>每个页就构成B+Tree中的一个叶子节点</strong>，每个叶子节点中的<strong>第一个数据的主键值作为这个叶子节点的主键值key</strong></p><p>为了进一步提高效率，又<strong>将这些叶子节点（也就是页）的key（还包括指针）存储到若干个页目录中</strong>（页目录也是一个页，默认大小为16KB）<strong>，形成了新的非叶子节点，B+Tree的深度加1</strong></p><p>那么整个B+Tree内的节点数量和深度实际上就会随着存储数据量动态变化</p><p>从物理IO的角度：</p><p>每个节点都对应物理存储上的一块磁盘空间，InnoDB存储引擎将<strong>B+Tree的根节点存储在内存中</strong>（这也是提高效率的做法之一）。当我们<strong>查询数据对B+Tree进行遍历时，实际就是连续的磁盘I/O</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/20160202205105560.png"></p></li><li><h4 id="B-Tree相比于BTree"><a href="#B-Tree相比于BTree" class="headerlink" title="B+Tree相比于BTree"></a>B+Tree相比于BTree</h4><blockquote><p>B+Tree是在BTree基础上的一种优化，使B+Tree更加适合实现外存储索引结构</p></blockquote><ul><li>B+Tree的<strong>非叶子节点只存储键值信息</strong>，BTree的叶子节点和非叶子节点均存储键值信息和数据</li><li>B+Tree的数据记录都存放在叶子节点中</li><li>B+Tree的所有叶子节点之间都有一个链指针</li></ul></li><li><h4 id="从IO角度看待B-Tree的优势"><a href="#从IO角度看待B-Tree的优势" class="headerlink" title="从IO角度看待B+Tree的优势"></a>从IO角度看待B+Tree的优势</h4><ul><li><p>每个节点它内部的数据包含键值，数据值和指针，它们都会占用一定的空间，但每个页的存储空间有限，又由于键值跟指针值占用字节大小一般是比较固定的，那么<strong>节点（一个页内）能存储多少个键值就取决于数据的大小</strong></p><blockquote><p>主键为int类型或者bigint，占用4字节或者8字节，指针一般占用4字节或者8字节</p></blockquote></li><li><p>对于BTree结构来说，它的非叶子节点存放键值，数据值和指针，当<strong>数据值较大时，就会导致BTree的非叶子节点所能存储的键值数量减少</strong>，如果<strong>存储的数据量很大的话，还可能导致BTree的深度变大，增加磁盘I/O次数</strong>，进而影响查询效率</p></li><li><p>对于B+Tree结构，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，<strong>非叶子节点上只存储键值跟指针</strong>，这样可以很大程度地增加非叶子节点可以存储的键值数量，从而降低B+Tree深度，避免增加磁盘I/O次数</p><blockquote><p>InnoDB存储引擎中页的大小为16KB，每个节点中存储的数据包含了数据的键值、数据值以及指针</p><p>一般表的主键类型为int（占用4个字节）或BIGINT（占用8个字节）、指针一般占用4或者8个字节</p><p>即估算一个页中大概存储16KB/(8B+8B)=1K个键，而一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。 </p></blockquote></li><li><p>实际情况中，每个节点可能无法填充满，因此在数据库中，<strong>B+Tree的高度一般都在2-4层</strong></p></li><li><p><strong>MySQL通过主键查找某一键值的行记录时最多只需要1-3次磁盘I/O</strong></p><blockquote><p>B+Tree根节点存储在内存，因此实际上是 1次内存访问 + 1-3次磁盘I/O</p></blockquote></li></ul></li><li><h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="==聚簇索引和非聚簇索引=="></a>==聚簇索引和非聚簇索引==</h4><ul><li><p><strong>聚簇索引</strong>：<strong>将数据存储和索引（键值和数据值）放到一起</strong>，索引结构的叶子节点保存了行数据</p></li><li><p><strong>非聚簇索引</strong>：<strong>将数据与索引分开存储</strong>，索引结构的叶子节点保存指向行数据的位置（MyISAM）</p><blockquote><p>在InnoDB中，在聚簇索引之上创建的索引统称为辅助索引，而非聚簇索引都是辅助索引，包括复合索引、唯一索引、前缀索引（单值索引）。</p><p><strong>辅助索引的叶子节点存储的不是行数据的物理位置，而是主键值</strong>，所以使用辅助索引访问数据通常都需要二次查找</p></blockquote></li></ul></li><li><h4 id="BTree索引在主要存储引擎的实现方式："><a href="#BTree索引在主要存储引擎的实现方式：" class="headerlink" title="BTree索引在主要存储引擎的实现方式："></a>BTree索引在主要存储引擎的实现方式：</h4><ul><li><h5 id="MyISAM使用非聚簇索引，B-Tree叶子节点的data域存放的是数据记录的地址（索引文件与数据文件分离）"><a href="#MyISAM使用非聚簇索引，B-Tree叶子节点的data域存放的是数据记录的地址（索引文件与数据文件分离）" class="headerlink" title="MyISAM使用非聚簇索引，B+Tree叶子节点的data域存放的是数据记录的地址（索引文件与数据文件分离）"></a>MyISAM使用非聚簇索引，B+Tree叶子节点的data域存放的是数据记录的地址（索引文件与数据文件分离）</h5><blockquote><p>主键索引B+Tree的叶节点存储了主键，而辅助建索引B+Tree树存储了辅助键,表数据存储在独立的地方</p></blockquote><ul><li>在索引检索的时候，首先按照B+Tree搜索算法搜索索引。</li><li>如果指定的Key存在，则取出其data域的值，然后以data域的值作为地址读取相应的数据记录</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/59066cb190ec7579c34e2cd77a1f47e8b68.jpg"></p><ul><li><h5 id="InnoDB使用聚簇索引，数据文件本身就是B-Tree的一个索引结构，B-Tree叶节点的data域保存了完整的数据记录"><a href="#InnoDB使用聚簇索引，数据文件本身就是B-Tree的一个索引结构，B-Tree叶节点的data域保存了完整的数据记录" class="headerlink" title="InnoDB使用聚簇索引，数据文件本身就是B+Tree的一个索引结构，B+Tree叶节点的data域保存了完整的数据记录"></a>InnoDB使用聚簇索引，数据文件本身就是B+Tree的一个索引结构，B+Tree叶节点的data域保存了完整的数据记录</h5><blockquote><p>主键组织到一棵B+树中，而行数据就储存在叶子节点,</p><p>InnoDB表数据文件本身就是主索引，这个索引的key是数据表的主键，</p></blockquote><ul><li>使用聚簇索引查询，按照B+树的检索算法查找到对应的叶节点，直接获得行数据。</li><li>除主索引外的其余索引都作为辅助索引，辅助索引的data域存储<strong>相应记录主键的值</strong>，辅助索引查询需要经过两步：<ul><li>在辅助索引B+树中按照检索算法查找到叶节点获取对应的主键</li><li>使用主键在主索引B+树中再执行一次检索算法，最终到达叶子节点，获取行数据</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/ce9bedd0dc9013e14e5f450e2149704bef5.jpg"></p><ul><li><h5 id="InnoDB与MyISAM的实现区别："><a href="#InnoDB与MyISAM的实现区别：" class="headerlink" title="InnoDB与MyISAM的实现区别："></a>InnoDB与MyISAM的实现区别：</h5><ul><li>在根据主索引搜索值时，直接找到key所在的节点即可取出数据；</li><li>在根据辅助索引搜索时，则需要先取出主键的值，再走一遍主索引</li></ul><blockquote><p>因此在设计表时，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，容易造成主索引频繁分裂</p></blockquote></li></ul></li></ul><p>参考链接：<a href="https://www.cnblogs.com/lianzhilei/p/11250589.html">https://www.cnblogs.com/lianzhilei/p/11250589.html</a></p><p>​                    <a href="https://www.bilibili.com/video/BV19y4y127h4">https://www.bilibili.com/video/BV19y4y127h4</a></p>]]></content>
    
    
    <summary type="html">MySQL索引概述</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MVCC多版本并发控制</title>
    <link href="http://example.com/2021/08/05/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2021/08/05/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2021-08-05T13:39:15.000Z</published>
    <updated>2021-09-17T18:55:50.666Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h2><h3 id="1-何为MVCC"><a href="#1-何为MVCC" class="headerlink" title="1. 何为MVCC"></a>1. 何为MVCC</h3><ul><li><p>MVCC ,全称Multi-Version Concurrency Control，<strong>多版本并发控制</strong>，在数据库管理系统中实现对数据库的并发访问</p><blockquote><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据并发性能，用更好的方式去处理读写冲突</p><p>实现不加锁、非阻塞并发读</p></blockquote><blockquote><p>MVCC在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程</p></blockquote></li></ul><h3 id="2-什么是当前读和快照读"><a href="#2-什么是当前读和快照读" class="headerlink" title="2.什么是当前读和快照读"></a>2.什么是当前读和快照读</h3><ul><li><h5 id="当前读：读取记录的最新版本，读取期间不允许其他并发事务修改当前记录，会对读取的记录加锁"><a href="#当前读：读取记录的最新版本，读取期间不允许其他并发事务修改当前记录，会对读取的记录加锁" class="headerlink" title="当前读：读取记录的最新版本，读取期间不允许其他并发事务修改当前记录，会对读取的记录加锁"></a>当前读：读取记录的最新版本，读取期间不允许其他并发事务修改当前记录，会对读取的记录加锁</h5><blockquote><p>select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读</p></blockquote></li><li><h5 id="快照读-读取记录不一定是最新版本，有可能是历史版本，是一种不加锁的非阻塞读，基于MVCC实现"><a href="#快照读-读取记录不一定是最新版本，有可能是历史版本，是一种不加锁的非阻塞读，基于MVCC实现" class="headerlink" title="快照读:读取记录不一定是最新版本，有可能是历史版本，是一种不加锁的非阻塞读，基于MVCC实现"></a>快照读:读取记录不一定是最新版本，有可能是历史版本，是一种不加锁的非阻塞读，基于MVCC实现</h5><blockquote><p>MVCC可以认为是行锁的一个变种，在很多情况下，避免了加锁操作，降低开销</p><p>快照读实现前提是隔离级别不是串行级别，串行级别下的快照会退化为当前读</p></blockquote></li><li><h5 id="当前读、快照读和MVCC的关系："><a href="#当前读、快照读和MVCC的关系：" class="headerlink" title="当前读、快照读和MVCC的关系："></a>当前读、快照读和MVCC的关系：</h5><ul><li>MVCC实现读（快照读）-写冲突不加锁</li><li>当前读是悲观锁的实现（加锁操作）</li></ul></li></ul><h3 id="3-MVCC解决的问题，以及好处"><a href="#3-MVCC解决的问题，以及好处" class="headerlink" title="3.MVCC解决的问题，以及好处"></a>3.MVCC解决的问题，以及好处</h3><ul><li><h5 id="数据库三种并发场景"><a href="#数据库三种并发场景" class="headerlink" title="数据库三种并发场景"></a>数据库三种并发场景</h5><ul><li>读-读：不存在任何问题，无需并发控制</li><li>读-写：存在线程安全问题，可能造成事务隔离性问题，如脏读、幻读、不可重复读</li><li>写-写：存在线程安全问题，可能存在更新丢失问题</li></ul></li><li><h5 id="MVCC带来的好处"><a href="#MVCC带来的好处" class="headerlink" title="MVCC带来的好处"></a>MVCC带来的好处</h5><blockquote><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制</p><p>它通过为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联</p><p>该操作只读事务开始前的数据库的快照</p></blockquote><ul><li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li><li>解决了脏读、幻读、不可重复读等事务隔离问题，但无法解决更新丢失问题</li></ul></li><li><h5 id="MVCC也可以和乐观锁悲观锁组合使用"><a href="#MVCC也可以和乐观锁悲观锁组合使用" class="headerlink" title="MVCC也可以和乐观锁悲观锁组合使用"></a>MVCC也可以和乐观锁悲观锁组合使用</h5></li></ul><h2 id="二、MVCC实现原理"><a href="#二、MVCC实现原理" class="headerlink" title="二、MVCC实现原理"></a>二、MVCC实现原理</h2><ul><li><p>MVCC的实现依赖于数据记录中的<strong>三个隐式字段、undo日志、Read View</strong>来实现</p></li><li><h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><blockquote><p>存放在表中的每行记录除了自定义的字段外，还有数据库隐式定义的字段</p></blockquote><ul><li><p>**DB_TRX_ID **:<strong>最近修改（修改/插入）事务ID</strong></p><blockquote><p>占6byte，记录创建这条记录/最后一次修改该记录的事务ID</p></blockquote></li><li><p>**DB_ROLL_PTR **:<strong>回滚指针</strong></p><blockquote><p>7byte，指向这条记录的上一个版本（存储于rollback segment里）</p></blockquote></li><li><p><strong>DB_ROW_ID</strong> :<strong>隐含的自增ID</strong>(隐藏主键)</p><blockquote><p>6byte，如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</p></blockquote><blockquote><p>实际上还有一个删除flag隐藏字段，记录更新或删除并不带真的删除，而是删除flag变了</p></blockquote></li></ul></li></ul><p><img src="D:\JavaStudy\面试突击\MySQL\MySQL图例\行记录字段.webp"></p><ul><li><h4 id="undo日志（分为两种）"><a href="#undo日志（分为两种）" class="headerlink" title="undo日志（分为两种）"></a>undo日志（分为两种）</h4><ul><li><h5 id="insert-undo-log：事务在insert新记录时产生的undo-log"><a href="#insert-undo-log：事务在insert新记录时产生的undo-log" class="headerlink" title="insert undo log：事务在insert新记录时产生的undo log"></a>insert undo log：事务在insert新记录时产生的undo log</h5><blockquote><p>只在事务回滚时需要，在事务提交之后可以被立即丢弃</p></blockquote></li><li><h5 id="update-undo-log：事务在进行update或delete时产生的undo-log"><a href="#update-undo-log：事务在进行update或delete时产生的undo-log" class="headerlink" title="update undo log：事务在进行update或delete时产生的undo log"></a>update undo log：事务在进行update或delete时产生的undo log</h5><blockquote><p>不仅在事务回滚时需要，在快照读时也需要，不能随便删除</p><p>只有在快照读或者回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p></blockquote><blockquote><h5 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h5><p>InnoDB更新或者删除操作是将记录的deleted_bit设置为true，并不真正将过时的记录删除</p><p>为了节省磁盘空间，<strong>InnoDB有专门的purge线程</strong>来清理delete_bit为true的记录</p><p>purge线程维护了它自己的read view（这个read view相当于系统中最老活跃事务的read view）</p><p>如果某个记录的deleted_bit为true，且记录的DB_TRX_ID在purge线程的read view中可见，那么这条记录是可以被安全清除的</p></blockquote></li><li><p>undo log实际上就是rollback segment中旧记录链</p></li><li><p><strong>不同事务或者相同事务对同一记录的修改，会导致该记录的undo log形成一条记录版本线性表</strong>，即链表</p><ul><li><strong>undo log的链首就是最新的旧记录</strong>（产生的旧记录添加到undo log的链头），链尾是最早的旧记录</li></ul></li></ul></li><li><h4 id="Read-View（读视图）"><a href="#Read-View（读视图）" class="headerlink" title="Read View（读视图）"></a>Read View（读视图）</h4><ul><li><p>事务进行快照读操作时产生的读视图（Read View），<strong>记录并维护系统当前活跃事务的ID</strong>（已开启但还未提交的事务）</p><blockquote><p>当每个事务开启时，都会被分配一个ID,这个ID递增，故最新的事务，ID越大</p></blockquote></li><li><p>Read View用于<strong>做可见性判断</strong></p><blockquote><p>当某个事务执行快照读时，对该记录创建一个Read View读视图，把它当作条件用来<strong>判断当前事务能够看到哪个版本的数据</strong>，既可能是最新的数据，也可能是undo log中的某个版本数据</p></blockquote></li><li><h5 id="Read-View执行流程"><a href="#Read-View执行流程" class="headerlink" title="Read View执行流程"></a>Read View执行流程</h5><ul><li><p>将要修改的数据的最新记录中的DB_TRX_ID取出来，与系统当前其他活跃事务的ID去对比（Read View维护）</p></li><li><p>如果根据DB_TRX_ID跟Read View中的ID比较的结果，判断不符合可见性</p></li><li><p>那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较</p><blockquote><p>即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起）</p></blockquote></li><li><p>找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p></li></ul></li><li><h5 id="Read-View遵循可见性算法"><a href="#Read-View遵循可见性算法" class="headerlink" title="Read View遵循可见性算法"></a>Read View遵循可见性算法</h5><ul><li><p>Read View维护系统当前活跃事务的ID，这些事务ID封装到一个数值列表中，分别有两个属性来记录这个数值中最大事务ID和最小事务ID，表示当前其他活跃事务ID的范围</p><blockquote><p>假定数值列表：list，最大事务ID ：up_limit_id，最小事务ID : low_limit_id</p></blockquote></li><li><p>首先比较DB_TRX_ID &lt; low_limit_id，如果成立，表示快照读这条记录之前DB_TRX_ID对应的事务就提交了，当前活动事务能够直接看到DB_TRX_ID所在的记录，如果不成立进入下一个判断</p></li><li><p>判断 DB_TRX_ID &gt;= up_limit_id,如果成立则代表DB_TRX_ID 所在记录是在对应的ReadView生成之后才出现的，故对当前活动事务不可见，如果小于则进入下一个判断</p></li><li><p>list.contains(DB_TRX_ID),即判断DB_TRX_ID是否在活跃事务中，</p><ul><li>如果在，则代表事务还未提交，对于活动事务而言记录不可见（会根据回滚指针依次判断历史版本（快照）是否可见）</li><li>如果不在，说明DB_TRX_ID事务已经提交，对应记录可见</li></ul></li></ul></li><li><p>案例</p><blockquote><p>假设当前列表里的事务id为[80,100]</p><p>如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。</p><p>如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。如</p><p>果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。</p></blockquote></li></ul></li><li><h4 id="MVCC在已提交读-READ-COMMITTD-RC-和可重复读-REPEATABLE-READ-RR-上的区别就是基于ReadView的创建"><a href="#MVCC在已提交读-READ-COMMITTD-RC-和可重复读-REPEATABLE-READ-RR-上的区别就是基于ReadView的创建" class="headerlink" title="MVCC在已提交读(READ COMMITTD/RC)和可重复读(REPEATABLE READ/RR)上的区别就是基于ReadView的创建"></a>MVCC在已提交读(READ COMMITTD/RC)和可重复读(REPEATABLE READ/RR)上的区别就是基于ReadView的创建</h4><ul><li>**RC(已提交读-READ COMMITTD)**级别下：<ul><li><strong>事务中的每次快照读都会重新生成一个快照（记录版本）和Read View</strong></li></ul></li><li>**RR(可重复读(REPEATABLE READ)**级别下：<ul><li><strong>事务中第一次进行快照读时会生成一个ReadView，此后在调用快照读时，都是使用同一个Read View</strong></li></ul></li></ul></li></ul><p>参考链接：<a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal解析</title>
    <link href="http://example.com/2021/07/22/ThreadLocal/"/>
    <id>http://example.com/2021/07/22/ThreadLocal/</id>
    <published>2021-07-22T10:06:52.000Z</published>
    <updated>2021-09-17T18:35:43.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><ul><li><h4 id="ThreadLocal是由JDK包提供的，它提供线程本地变量，让每个线程绑定自己的值"><a href="#ThreadLocal是由JDK包提供的，它提供线程本地变量，让每个线程绑定自己的值" class="headerlink" title="ThreadLocal是由JDK包提供的，它提供线程本地变量，让每个线程绑定自己的值"></a>ThreadLocal是由JDK包提供的，它提供线程本地变量，让每个线程绑定自己的值</h4><blockquote><p>如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会获得这个变量的本地副本值</p><p>在多线程实际操作中，每个线程操作的都是自己本地内存的变量</p></blockquote></li><li><h5 id="使用get-和set-方法来获取默认值或将其值更改为当前线程所存的副本的值"><a href="#使用get-和set-方法来获取默认值或将其值更改为当前线程所存的副本的值" class="headerlink" title="使用get()和set()方法来获取默认值或将其值更改为当前线程所存的副本的值"></a>使用<code>get()</code>和<code>set()</code>方法来获取默认值或将其值更改为当前线程所存的副本的值</h5></li><li><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul><li>进行对象跨层传递，ThreadLocal可以避免多次传递</li><li>线程间数据隔离</li><li>进行事务操作，用于存储线程事务信息</li><li>数据库连接，Session会话管理</li></ul></li></ul><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><ul><li><h4 id="从Thread类底层出发"><a href="#从Thread类底层出发" class="headerlink" title="从Thread类底层出发"></a>从Thread类底层出发</h4><blockquote><p>在JDK8中，<code>ThreadLocal</code>的设计是每个<code>Thread</code>维护一个<code>ThreadLocalMap</code></p><p>这个Map的<code>key</code>是<code>ThreadLocal</code>实例，<code>value</code>是真正要存储的值<code>Object</code></p><p>（ThreadlLocalMap可以理解为<code>ThreadLocal</code>类实现的定制化<code>HashMap</code>）</p></blockquote><blockquote><p><code>ThreadLocalMap</code>默认为null，只有在调用<code>ThreadLocal</code>的<code>set</code>或<code>get</code>方法时（实际上调用的是<code>ThreadLocalMap</code>类中的<code>get()、set()</code>），才会创建</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/ThreadLocalMap%E7%BB%93%E6%9E%84.png"></p></li><li><h4 id="分析ThreadLocal的核心方法set、get、remove"><a href="#分析ThreadLocal的核心方法set、get、remove" class="headerlink" title="分析ThreadLocal的核心方法set、get、remove"></a>分析ThreadLocal的核心方法<code>set</code>、<code>get</code>、<code>remove</code></h4><ul><li><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">// 判断map是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 存在则调用ThreadLocalMap的set方法添加entry，key为当前ThreadLocal的引用，value为传入的具体值</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//当前线程不存在ThreadLocalMap对象则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">            <span class="comment">// 将当前线程和要设置的值value作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取当前线程Thread维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the map 当前线程维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建当前线程Thread维护的ThreadLocalMap （完成初始化工作）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h4 id="set执行流程"><a href="#set执行流程" class="headerlink" title="set执行流程"></a>set执行流程</h4><ul><li>首先获取当前线程，并根据当前线程获取一个Map（此线程对象中维护的<code>ThreadLocalMap</code>对象）</li><li>如果此Map不为空，则将参数（ThreadLocal的引用–设置的值）设置到Map中</li><li>如果Map为空，则为该线程创建ThreadLocalMap，并设置初始值</li></ul></li></ul><ul><li><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前线程中设置的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    * 如果当前线程没有对应的ThreadLocal值，</span></span><br><span class="line"><span class="comment">    * 则它会通过调用setInitialValue 方法进行初始化值</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果此map存在，以当前的ThreadLocal 为 key，调用getEntry获取对应的entry</span></span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// 判断获取到的entry是否为空</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="comment">// entry存在，则获取entry中对应的 value值</span></span><br><span class="line">               <span class="comment">// 即为当前线程中设置的此ThreadLocal的值</span></span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">       第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">       第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">       <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">       T value = initialValue();</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 3）</span></span><br><span class="line">           <span class="comment">// 与set方法中一致：</span></span><br><span class="line">           <span class="comment">// 当前线程Thread 不存在ThreadLocalMap对象，调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">           <span class="comment">// 并将当前线程和value作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">       <span class="comment">// 返回设置的值value</span></span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">     * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。</span></span><br><span class="line"><span class="comment">     * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> null&#125;;</span></span><br><span class="line"><span class="comment">     * 如果程序员想ThreadLocal线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment">     * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment">     * 通常, 可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="get执行流程"><a href="#get执行流程" class="headerlink" title="get执行流程"></a>get执行流程</h4><ul><li><p>获取当前线程，根据当前线程获取其维护的<code>ThreadLocalMap</code></p></li><li><p>如果获取的Map不为空，则在Map中以<code>ThreadLocal</code>的引用值作为key获取其对应的entry</p></li><li><p>如果获取的entry不为空，则返回entry中的value</p></li><li><p>当Map为空或者根据<code>ThreadLocal</code>引用获得的entry为空时，通过<code>initialValue</code>获取初始值value（<strong>默认为null</strong>，initialValue 可以被重写）</p><ul><li>若Map不为空，则以<code>ThreadLocal</code>引用和<strong>通过initialValue获得value值</strong>作为entry存放到map中</li><li>若Map为空，先初始化Map，再以<code>ThreadLocal</code>引用和该value作为第一个entry设置到map中</li><li>返回value</li></ul></li></ul></li><li><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">           <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>执行流程</p><ul><li>获取当前线程，并根据当前线程获取一个Map</li><li>如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry</li></ul></li></ul></li></ul><h2 id="ThreadLocalMap原理"><a href="#ThreadLocalMap原理" class="headerlink" title="ThreadLocalMap原理"></a>ThreadLocalMap原理</h2><ul><li><h3 id="ThreadLocalMap框架"><a href="#ThreadLocalMap框架" class="headerlink" title="ThreadLocalMap框架"></a>ThreadLocalMap框架</h3><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/ThreadLocalMap%E5%BA%95%E5%B1%82.png"></p><ul><li>INITIAL_CAPACITY ：<code>ThreadLocalMap</code>的初始容量，默认为 16 ，且必须是 2 的整次幂</li><li>table ：Entry 类型的数组，用于存储键值对</li><li>size：table中entry的个数</li><li>thresold ：扩容阈值，根据该值判断是否需要对数组table进行扩容</li></ul><blockquote><p>类似于HashMap的结构</p></blockquote></li><li><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承自WeakReference(弱引用)，并且固定以ThreadLocal的引用作为key.</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == null)，意味着key不再被引用，（GC发现弱引用后会自动清除）</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Enrty 继承 <strong>WeakReference</strong>（弱引用），也就是<strong>key（ThreadLocal）是弱引用</strong></p><ul><li>目的是为了将<code>ThreadLocal</code>对象实例的生命周期和线程生命周期解绑</li></ul></li></ul></li><li><h3 id="Thread与ThreadLocal整体架构图"><a href="#Thread与ThreadLocal整体架构图" class="headerlink" title="Thread与ThreadLocal整体架构图"></a>Thread与ThreadLocal整体架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/Blonde-dot/picGo/img/ThreadLocal%E5%BC%95%E7%94%A8%E7%BB%93%E6%9E%84.png"></p></li></ul><ul><li><h3 id="ThreadLocalMap中的-set-方法"><a href="#ThreadLocalMap中的-set-方法" class="headerlink" title="ThreadLocalMap中的 set 方法"></a><code>ThreadLocalMap</code>中的 set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="comment">//计算索引（即新entry插入位置，与HashMap中的路由算法相似）</span></span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用线性探测法查找元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//ThreadLocal 对应的 key 存在，直接覆盖旧值</span></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key为 null，但是值不为 null，说明在此之前， ThreadLocal 对象的引用已经被回收了</span></span><br><span class="line">           <span class="comment">// 当前数组中的 Entry 是一个陈旧（stale）的元素</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏</span></span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">             * 这类数据关联的key已经被回收，属于无效entry，为了防止内存泄露问题，将这个Entry(table[index])置为null，方便GC回收内存空间</span></span><br><span class="line"><span class="comment">             * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行 * rehash（执行一次全表的扫描清理工作）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul><li>根据key（ThreadLocal）计算出索引值 i，查找 i 位置上的 Entry</li><li>若Entry已经存在并且key等于传入的key，那么直接将这个Entry赋予新的value值（覆盖）</li><li>若Entry已存在，但 key 为null，那么调用<code>replaceStaleEntry</code>替换这个key为空的Entry</li><li>若不符合以上两种情况，则从 i 值出发，不断循环检测，直到遇到Entry为null的地方<ul><li>如果在找到null时，整个循环过程中没有return值出去，则就在这个null值的位置，新建一个Entry，并将对应key和value插入，同时 size 加1</li></ul></li><li>最后调用 <code>cleanSomeSlots</code>，清理key为null的Entry，该方法返回布尔型变量，判断是否清理了Entry</li><li>再判断当前Entry数组容量是否达到了扩容阈值，达到的话调用<code>rehash</code>方法执行一次全表的扫描清理</li></ul></li><li><h3 id="ThreadLocalMap中使用线性探测法来解决哈希冲突"><a href="#ThreadLocalMap中使用线性探测法来解决哈希冲突" class="headerlink" title="ThreadLocalMap中使用线性探测法来解决哈希冲突"></a>ThreadLocalMap中使用<code>线性探测法</code>来解决哈希冲突</h3><blockquote><p>不同于HashMap的拉链法，HashMap将发生哈希冲突的元素链接形成链表</p><p>ThreadLocalMap中，当发生了hash冲突，该方法一次探测下一个地址，<strong>直到查找到有空的位置</strong>后插入，若整个数组空间都找不到空余的地址，则产生内存溢出</p></blockquote></li></ul><h2 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h2><ul><li><h4 id="内存泄露-Memory-Leak"><a href="#内存泄露-Memory-Leak" class="headerlink" title="内存泄露(Memory Leak)"></a>内存泄露(Memory Leak)</h4><blockquote><p>程序中<strong>已动态分配的堆内存</strong>由于某种原因，导致程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p><strong>内存泄露的堆积终将导致内存溢出</strong></p></blockquote></li><li><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><blockquote><p>对于弱引用的对象，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只只具有弱引用的对象，不管当前内存空间足够与否，都会直接回收它的内存</p></blockquote></li><li><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><blockquote><p>强引用就是最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象“还活着”，垃圾回收器就不会回收这类对象</p></blockquote></li></ul><h4 id="ThreadLocalMap中使用的-key-为ThreadLocal的弱引用，而-value-是强引用"><a href="#ThreadLocalMap中使用的-key-为ThreadLocal的弱引用，而-value-是强引用" class="headerlink" title="ThreadLocalMap中使用的 key 为ThreadLocal的弱引用，而 value 是强引用"></a><code>ThreadLocalMap</code>中使用的 key 为<code>ThreadLocal</code>的弱引用，而 value 是强引用</h4><blockquote><p>对于没有手动调用remove移除的entry，在JVM进行GC（垃圾回收）时，使用弱引用的key可能会被清理掉，但该key对应的 value由于是强引用，不会被清理，这时候<code>ThreadLocalMap</code>内部的Entry数组中就出现 key 为 null 的 无效Entry。</p><p>如果不单独remove的话， value 永远无法被 GC 回收，这个时候就可以能会产生内存泄露</p></blockquote><h4 id="如果ThreadLocalMap中key为ThreadLocal强引用？"><a href="#如果ThreadLocalMap中key为ThreadLocal强引用？" class="headerlink" title="如果ThreadLocalMap中key为ThreadLocal强引用？"></a>如果<code>ThreadLocalMap</code>中key为<code>ThreadLocal</code>强引用？</h4><blockquote><p>假设在业务代码中使用完<code>ThreadLocal</code>，那么此时<code>ThreadLocal</code><strong>的引用</strong>就会被回收，</p><p>但由于在<code>ThreadLocalMap</code>中的 key 强引用了该<code>ThreadLocal</code>，导致<code>ThreadLocal</code>无法回收</p><p>在没有手动删除（remove）这个Entry以及<strong>当前线程</strong>（CurrentThread）（即引用了该ThreadLocal的线程）依然运行的情况下，该Entry （包含了<code>ThreadLocal</code>和存放的value）始终不会被 JVM 回收，这个时候依然会导致Entry数组内存泄露</p></blockquote><h5 id="也就是说，ThreadLocalMap中的key就算使用强引用而不是弱引用，也无法避免内存泄漏"><a href="#也就是说，ThreadLocalMap中的key就算使用强引用而不是弱引用，也无法避免内存泄漏" class="headerlink" title="也就是说，ThreadLocalMap中的key就算使用强引用而不是弱引用，也无法避免内存泄漏"></a>也就是说，ThreadLocalMap中的key就算使用强引用而不是弱引用，也无法避免内存泄漏</h5><h4 id="内存泄漏的根本原因？"><a href="#内存泄漏的根本原因？" class="headerlink" title="==内存泄漏的根本原因？=="></a>==内存泄漏的根本原因？==</h4><blockquote><h4 id="ThreadLocalMap的生命周期跟Thread一样长"><a href="#ThreadLocalMap的生命周期跟Thread一样长" class="headerlink" title="ThreadLocalMap的生命周期跟Thread一样长"></a>ThreadLocalMap的生命周期跟Thread一样长</h4><p>ThreadLocalMap作为Thread中的属性，被当前线程所引用，所以它以及它内部存放key-value的<strong>Entry数组</strong>的生命周期跟Thread一样长</p></blockquote><h4 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h4><blockquote><p><strong>在<code>ThreadLocalMap</code>中的<code>set/getEntry</code>方法中，会对 key 为 null（也即是<code>ThreadLocal</code>为null）进行判断，如果为 null 的话，那么会将 value 值置为 null</strong></p><p>这就意味着，当前线程依然运行的前提下，即使没有手动调用remove方法移除对应Entry，弱引用的ThreadLocal 被回收后，在下次进行 <code>set/get</code>方法时，也会将该 key 对应的 value 设置为null值，在JVM进行下一次 GC 时，value将被回收。</p><p>也就是说，<strong>弱引用比强引用多了一层保障</strong></p><p>要避免内存泄漏有两种方式</p><ol><li>使用完 <code>ThreadLocal</code>，调用其 remove 方法删除对应的 Entry</li><li>使用完 <code>ThreadLocal</code>，当前 <code>Thread</code>也随之运行结束</li></ol><p>相对于第一种方式，第二种方式更不好控制。热别是在使用线程池的时候，线程即使结束了也是不会被销毁的</p></blockquote><p>参考链接：<a href="https://blog.csdn.net/weixin_44050144/article/details/113061884">https://blog.csdn.net/weixin_44050144/article/details/113061884</a></p>]]></content>
    
    
    <summary type="html">ThreadLocal解析</summary>
    
    
    
    
    <category term="Java并发" scheme="http://example.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2021/07/21/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/07/21/HashMap%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-07-21T10:06:46.000Z</published>
    <updated>2021-09-17T17:12:42.072Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="HashMap底层是数组和链表结合在一起使用的散列表"><a href="#HashMap底层是数组和链表结合在一起使用的散列表" class="headerlink" title="HashMap底层是数组和链表结合在一起使用的散列表"></a>HashMap底层是数组和链表结合在一起使用的散列表</h3><blockquote><p><strong>在jdk1.8之后，还结合了红黑树</strong>（需要前置条件 –&gt; 哈希表元素总数大于64，且某个链表长度大于8）</p></blockquote><h3 id="底层："><a href="#底层：" class="headerlink" title="底层："></a>底层：</h3><ul><li><h4 id="HashMap中定义的重要参数"><a href="#HashMap中定义的重要参数" class="headerlink" title="HashMap中定义的重要参数"></a>HashMap中定义的重要参数</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 默认数组table长度（容量）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 数组table最大长度（容量）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 缺省负载因子大小 （一般不改，稍作了解）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 树化阈值 （条件1）</span></span><br><span class="line"><span class="comment">    * 即链表长度超过该值时转化为红黑树 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 红黑树降级为链表的阈值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 同样是树化阈值 （条件2）</span></span><br><span class="line"><span class="comment">    * 当哈希表中所有元素超过该值时转化为红黑树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有当table中某个链表长度大于8，且table内元素总数大于64，才会将链表升级为红黑树</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表中的链表 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 哈希表（真正存储数据，是一个以链表作为元素类型的数组 或者说 封装链表的数组）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当前哈希表中元素的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当前哈希表结构修改次数（插入或修改、替换key不算）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩容阈值，当哈希表中的元素超过该阈值时，触发扩容机制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 负载因子</span></span><br><span class="line"><span class="comment">* 用于计算 threshold</span></span><br><span class="line"><span class="comment">* threshold = capacity(当前table长度) * loadFactor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><h4 id="HashMap构造方法"><a href="#HashMap构造方法" class="headerlink" title="HashMap构造方法"></a>HashMap构造方法</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果传入的容量小于0，抛出容量不合法错误</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="comment">// 如果传入的容量大于默认的最大容量，将最大容量作为哈希表容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果负载因子小于0，抛出负载因子不合法错误</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) <span class="keyword">throw</span>  <span class="keyword">new</span> </span><br><span class="line">       IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验都通过，进行赋值操作</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有传入容量时，采用初始容量initial capacity（16）和负载因子（0.75）来初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = </span><br><span class="line">        DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="tableSizeFor-initialCapacity"><a href="#tableSizeFor-initialCapacity" class="headerlink" title="tableSizeFor(initialCapacity);"></a>tableSizeFor(initialCapacity);</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给定容量的2的幂次方大小的值</span></span><br><span class="line"><span class="comment">     * 或者说 计算大于或等于最接近给定容量值的一个2的次方数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Integer类中的numberOfLeadingZeros</span></span><br><span class="line"><span class="comment">// 参考资料 </span></span><br><span class="line"><span class="comment">// https://www.cnblogs.com/xiepl1997/p/13479769.html</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/m0_48333563/article/details/107981891</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h3 id="HashMap-的put方法流程"><a href="#HashMap-的put方法流程" class="headerlink" title="HashMap 的put方法流程"></a>HashMap 的put方法流程</h3><p>![](D:\JavaStudy\笔记总结\图例\Java进阶\HashMap - put流程.png)</p><blockquote><p><strong>路由寻址公式：（table.length - 1） &amp; node.hash</strong></p><p>数组的长度-1 跟 key的hashcode值**经过扰动函数hash()**处理过得到的hash值 </p><p>进行 与运算（都为1 取 1，有0则取0）</p><p>本质是 key的hashcode值 对 数组长度 table.length 进行求余计算（取模）</p></blockquote></li><li><h4 id="扰乱函数-hash"><a href="#扰乱函数-hash" class="headerlink" title="扰乱函数 - hash"></a>扰乱函数 - hash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扰动函数hash()方法</span></span><br><span class="line"><span class="comment">* 根据 传入key 的hashcode值，让其高低16位进行异或计算，使得高16位也参与路由运算</span></span><br><span class="line"><span class="comment">* hash = h ^ (h &gt;&gt;&gt; 16) </span></span><br><span class="line"><span class="comment">* 作用：为了增加随机性，减少哈希冲突</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="核心方法-put"><a href="#核心方法-put" class="headerlink" title="核心方法 - put"></a>核心方法 - put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * tab ：散列表</span></span><br><span class="line"><span class="comment">    * p ：当前散列表的元素</span></span><br><span class="line"><span class="comment">    * n ：散列表数组的长度</span></span><br><span class="line"><span class="comment">    * i ：当前元素路由寻址的结果，即桶位（插入到散列表的位置）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 延迟散列表初始化逻辑</span></span><br><span class="line">        <span class="comment">// 原因：散列表是HashMap中最占用内存的部分，第一次添加元素时再初始化散列表可以节省内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 桶位为null，直接将待添加元素node：key-value插入该位置 </span></span><br><span class="line">    <span class="comment">// i = (n - 1) &amp; hash ：获取桶位</span></span><br><span class="line">    <span class="comment">// p ：当前桶位元素</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 桶位已经存在元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// e : 作为node临时对象元素</span></span><br><span class="line">            <span class="comment">// k : 表示临时key </span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 桶位中元素p的hash和待添加元素的hash相同，且p的key与待添加元素key地址相同</span></span><br><span class="line">            <span class="comment">// 准备替换元素（待添加元素替换掉p）</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 桶位元素当前已经树化（链表升级为红黑树）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 桶位元素p的类型是链表，且链表头元素与待插入元素不一致</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 迭代该链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 当前节点的下一位为空，说明已经迭代到链表末尾，没有出现相同的元素</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将待添加元素添加到链表末尾</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 判断当前所属链表是否触发树化（长度是否大于等于8）</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 进行树化（将链表转换为红黑树）</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 在链表内部找到完全相同的元素（hash值相等且key地址相同）</span></span><br><span class="line">                    <span class="comment">// 准备替换元素（待添加元素覆盖原本元素）</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果e不等于null，进行替换操作，使用带添加元素覆盖指定元素</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 散列表结构修改次数（替换不包括在内）</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    <span class="comment">// 判断当前散列表元素是否大于扩容阈值，决定是否扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>扩容的必要性</strong>：为了解决哈希冲突导致的元素链化严重，进而影响查询效率的问题</p><p>对于散列表，理论上查找一个元素只需要 O(1) 的时间复杂度，但随着散列表内元素的增多，元素会更加密集的分布在各链表之中，即每个链表的长度会一直增长，最终，散列表的查询可能退化为链表查询，这是效率极低的。</p><p>通过扩容（添加桶位，也是添加链表）可以使元素散列程度更高，查询更高效</p></blockquote><ul><li><h4 id="核心方法-扩容方法resize"><a href="#核心方法-扩容方法resize" class="headerlink" title="核心方法 - 扩容方法resize()"></a>核心方法 - 扩容方法resize()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * oldTab : 引用变量，负责扩容前的哈希表</span></span><br><span class="line"><span class="comment">     * oldCap ：表示扩容之前散列表数组的容量（长度）</span></span><br><span class="line"><span class="comment">     * oldThr ：扩表示容之前的阈值，即触发本次扩容的阈值</span></span><br><span class="line"><span class="comment">     * newCap ：扩容之后散列表数组的容量</span></span><br><span class="line"><span class="comment">     * newThr ：扩容之后，再次触发扩容的阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大条件 ：散列表已经初始化过（有数据），即这是一次正常扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 原散列表的容量已经大于或等于最大容量值，无法再进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 将最大容量值作为下次触发扩容的阈值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 原散列表容量 位左移一位（即原来值 * 2 ）实现翻倍，并且赋值给 新散列表容量</span></span><br><span class="line">        <span class="comment">// 如果 新散列表容量 小于 最大容量值 且 原散列表容量 也大于等于默认容量16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 设置 新扩容阈值 为 旧扩容阈值 的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大条件 ：不满足oldCap &gt; 0,即散列表还未初始化过 （内部没有数据）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  散列表未初始化，但扩容阈值有值,可能导致这个情况的三类方法</span></span><br><span class="line"><span class="comment">      *1.new HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line"><span class="comment">      * 2.new HashMap(initCap)</span></span><br><span class="line"><span class="comment">      * 3.new HashMap(map)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 将旧扩融阈值作为新散列表容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同时不满足 oldCap &gt; 0 和 oldThr &gt; 0</span></span><br><span class="line">    <span class="comment">// new HashMap()时可能出现这种情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;          </span><br><span class="line">        <span class="comment">// 按照默认值初始化 新散列表容量 以及 新扩容阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 根据前置判断条件，有两种情况可以导致 newThr没有被赋值</span></span><br><span class="line"><span class="comment">      * 散列表已经初始化，但原散列表容量小于系统默认初始化容量（即oldCap = 4 或 8）</span></span><br><span class="line"><span class="comment">      * 散列表还未初始化，但扩容阈值已经赋值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过newCap新的散列表容量 和 loadFacotr计算出新的扩容阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以上代码用于获取newCap和newThr，还未进行扩容</span></span><br><span class="line">    <span class="comment">/* ---------------------------------------------------------------- */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 核心部分！！扩容部分</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 以新散列表容量newCap声明一个更大的数组，对于原散列表来说，可能是重新引用，也可能是第一次初始化</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// HashMap本次扩容之前，不为null</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 指示当前桶位元素（node节点）</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将链表头节点赋值给e，且不为null，从头节点开始遍历</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将当前节点值传递到e后，置空，方便JVM回收旧散列表使用内存</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况1：当前桶位只有一个元素，没有发生过哈希冲突</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 使用路由算法计算e在新散列表中的桶位，并添加到新散列表</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况2：当前桶位元素是红黑树类型</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况3：当前桶位元素是链表类型</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 将链表拆分分为低位链表和高位链表</span></span><br><span class="line">                    <span class="comment">// 低位链表：存放在新散列表的下标位置（桶位），与旧散列表的下标位置一致</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 高位链表：存放在新散列表的下标位置，为旧散列表的下标位置 + 旧散列表容量</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    </span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// oldCap 一定是 2 的幂次方，即对应的二进制数一定只有一个非0最高位（如1000,10,10000）</span></span><br><span class="line">                        <span class="comment">// e.hash &amp; oldCap 的结果，只需要看oldCap非0最高位对应的结果 </span></span><br><span class="line">                        <span class="comment">// 如果是0，将其存放到低位链表中</span></span><br><span class="line">                        <span class="comment">// 如果为1，将该元素存放高位链表</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);  </span><br><span class="line">                    <span class="comment">// 将低位链表的元素存放到对应桶位链表内</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将元素next置空，因为当前元素next指向的元素可能存放于高位链表</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 将低位链表的元素存放到新散列表中，其桶位跟旧散列表桶位一致（j）</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将高位链表中的元素存放到对应桶位的链表中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将元素next置空，因为当前元素next指向的元素可能存放于低位链表</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 高位链表中元素存放桶位为 原散列表存放桶位 + 原散列表容量（长度）</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="关于扩容后元素存放-（低位链表和高位链表的区分）"><a href="#关于扩容后元素存放-（低位链表和高位链表的区分）" class="headerlink" title="关于扩容后元素存放 （低位链表和高位链表的区分）"></a>关于扩容后元素存放 （低位链表和高位链表的区分）</h4><p><img src="D:\JavaStudy\笔记总结\图例\Java进阶\哈希表扩容例子.png"></p><blockquote><p>此例中，原散列表数组长度为16，扩容后变为32，观察扩容前散列表数组，</p><p>在桶位15的链表中，有两个元素放到了新散列表中桶位为15的链表（保持一致），另外两个元素则存放</p><p>到了新散列表中桶位为31的链表当中。</p><p>由于路由算法 hash &amp; length -1 可知，</p><p>桶位 15 的计算过程为：hash &amp; 1111 (即16-1=15的二进制) = 1111（15），根据这个公式可以反推出，</p><p>桶位15下的链表元素的hash值，后四位必然都是 1111，前面的位数未参与运算</p><p>在扩容后，第五位得以参与路由运算，计算新散列表的桶位值时，</p><p>可以分为 01111 &amp; 11111 ( 32-1=31) = 01111 （15） 与原散列表存放桶位一致，将这类元素存放的链表统一称为低位链表</p><p>11111 &amp; 11111 = 11111 （31）桶位为原散列表存放桶位 + 原散列表容量长度，此类元素存放链表称为高位链表</p></blockquote></li><li><h4 id="核心方法-get"><a href="#核心方法-get" class="headerlink" title="核心方法 - get"></a>核心方法 - get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * tab : 引用当前HashMap的散列表</span></span><br><span class="line"><span class="comment">     * first ： 桶位中的头元素</span></span><br><span class="line"><span class="comment">     * e : 临时node元素</span></span><br><span class="line"><span class="comment">     * n : 散列表数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断散列表是否有内容，且目标桶位是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况1：定位的桶位元素就是目标元素</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况2:当前桶位可能是链表或者红黑树，且头元素不是目标元素</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前桶位元素为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前桶位元素为链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 查看有无跟目标元素相等的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                    <span class="comment">// 迭代链表</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="核心方法-remove"><a href="#核心方法-remove" class="headerlink" title="核心方法 - remove"></a>核心方法 - remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * tab : 引用当前HashMap的散列表</span></span><br><span class="line"><span class="comment">     * p ：当前node元素</span></span><br><span class="line"><span class="comment">     * n ：n : 散列表数组长度</span></span><br><span class="line"><span class="comment">     * index ：寻址结果（桶位）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 判断散列表是否有内容，且目标桶位是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况1：当前桶位中的头元素即为目标删除元素</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况2:当前桶位可能是链表或者红黑树，且头元素不是目标元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">// 当前桶位元素为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">// 当前桶位元素为链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                         <span class="comment">// 查看有无跟目标元素相等的元素</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                        <span class="comment">// 迭代链表</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*---------------------------目标元素查找结束--------------------------*/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果查找结果不为空，删除目标元素</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">// 情况1：node是树节点，进行树节点移除（红黑树）</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况2：桶位头元素即为目标删除元素，直接将该头元素的下一位元素替换到桶位头节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况3：node是链表类型 </span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 将当前元素p的下一个元素设置为目标删除元素的下一位元素</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">HashMap源码解析</summary>
    
    
    
    
    <category term="Java集合" scheme="http://example.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用命令</title>
    <link href="http://example.com/2021/07/16/Redis%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>http://example.com/2021/07/16/Redis%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</id>
    <published>2021-07-16T13:39:15.000Z</published>
    <updated>2021-09-17T19:16:02.401Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Redis命令手册"><a href="#Redis命令手册" class="headerlink" title="Redis命令手册"></a>Redis命令手册</h2><h2 id="一、Redis的安装及启动关闭（redis不区分大小写）"><a href="#一、Redis的安装及启动关闭（redis不区分大小写）" class="headerlink" title="一、Redis的安装及启动关闭（redis不区分大小写）"></a>一、Redis的安装及启动关闭（redis不区分大小写）</h2><h3 id="1-Linux下安装redis（以6-2-1为例）"><a href="#1-Linux下安装redis（以6-2-1为例）" class="headerlink" title="1. Linux下安装redis（以6.2.1为例）"></a>1. Linux下安装redis（以6.2.1为例）</h3><ul><li>下载获得redis-6.2.1.tar.gz,将该压缩包放到<strong>Linux目录 /opt下</strong></li><li>cd 到 /opt 目录下，使用解压命令：<code>tar -zxvf redis-6.2.1.tar.gz</code>，解压完成出现文件夹redis-6.2.1</li><li>进入目录：cd redis-6.2.1 </li><li>在redis-6.2.1下执行 <code>make</code> 命令<ul><li>运行 make 命令可能会出现错误，解决方案<ul><li>安装 gcc ：<code>yum install gcc  -c++</code> （redis是基于C语言编写的，因此需要加入C语言支持包gcc）</li><li>再次 <code>make</code></li></ul></li></ul></li><li>make完成后继续执行 <code>make install</code></li></ul><h3 id="2-查看默认安装目录：usr-local-bin"><a href="#2-查看默认安装目录：usr-local-bin" class="headerlink" title="2.查看默认安装目录：usr/local/bin"></a>2.查看默认安装目录：usr/local/bin</h3><ul><li><code>redis-benchmark</code> ：服务启动后执行性能测试的工具</li><li><code>redis-check-aof</code> ：修复有问题aof文件（使用aof生成的持久化文件）</li><li><code>redis-check-dump</code>：修复有问题的dump.rdb文件（使用rdb生成的持久化文件）</li><li><code>redic-cli</code>：客户端，操作入口</li><li><code>redis-sentinel</code>：redis集群使用（哨兵服务器启动入口）</li><li><code>redis-server</code>：Redis服务器启动命令</li></ul><h3 id="3-启动"><a href="#3-启动" class="headerlink" title="3.启动"></a>3.启动</h3><ul><li><p>修改配置文件，vim redis.conf</p></li><li><p><code>daemonize no</code>修改成yes，允许redis服务后台启动（守护进程）</p></li><li><p>将默认的redis.conf拷贝到自定义的路径下，如<code>cp redis.conf /etc/myconf/redis.conf</code></p></li><li><p>进入 /usr/local/bin目录下运行redis-server，使用存放自定义配置文件夹下的配置文件启动</p><p><code>redis-server /etc/myconf/redis.conf</code> （后台启动）</p></li><li><p>在 /usr/local/bin 下运行 <code>redis-cli</code>/<code>redis-cli -p 6379</code>，以前台方式启动客户端</p></li></ul><h3 id="4-关闭"><a href="#4-关闭" class="headerlink" title="4.关闭"></a>4.关闭</h3><ul><li>单实例关闭：<code>redis-cli shutdown</code>，也可在服务器内使用shutdown关闭</li><li>多实例关闭，指定端口关闭：<code>redis-cli -p 6379 shutdown</code></li></ul><h2 id="二、Redis启动后杂项基础"><a href="#二、Redis启动后杂项基础" class="headerlink" title="二、Redis启动后杂项基础"></a>二、Redis启动后杂项基础</h2><h3 id="1-单进程"><a href="#1-单进程" class="headerlink" title="1.单进程"></a>1.单进程</h3><ul><li>redis使用<strong>单进程模型处理客户端的请求</strong>，对读写等事件的响应是通过对<strong>epoll函数</strong>的包装来做到的。<strong>Redis的实际处理速度完全依靠主进程的执行效率</strong></li><li>epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率</li></ul><h3 id="2-redis数据库的一些概念及操作"><a href="#2-redis数据库的一些概念及操作" class="headerlink" title="2.redis数据库的一些概念及操作"></a>2.redis数据库的一些概念及操作</h3><ul><li>默认16个数据库，以数组下标0-15存储，初始默认使用零号库</li><li>统一密码管理，16库都是同样密码</li><li><code>select 0-15</code> ：切换数据库</li><li><code>dbsize</code>：查看当前数据库中的key数量</li><li><code>flushdb</code>：清空当前库</li><li><code>flushall</code>：清空所有库</li></ul><h2 id="三、redis的五大数据类型"><a href="#三、redis的五大数据类型" class="headerlink" title="三、redis的五大数据类型"></a>三、redis的五大数据类型</h2><h3 id="1-redis-中-键（key）–-常用命令"><a href="#1-redis-中-键（key）–-常用命令" class="headerlink" title="1.redis 中 键（key）– 常用命令"></a>1.redis 中 键（key）– 常用命令</h3><ul><li><code>keys *</code>:查看所有key</li><li><code>exists key</code>：判断某个key是否存在</li><li><code>move key dbID(0-15)</code>：移除数据库（很少使用）</li><li><code>expire key second（秒）</code>：为给定的key设置过期时间</li><li><code>ttl key</code>：查看key还有多少秒过期，**-1 表示永不过时**， <strong>-2 表示已过期</strong></li><li><code>type key</code>：查看key类型</li></ul><h3 id="2-redis-字符串（String）–-常用命令"><a href="#2-redis-字符串（String）–-常用命令" class="headerlink" title="2. redis 字符串（String）– 常用命令"></a>2. redis 字符串（String）– 常用命令</h3><ul><li><code>set key value</code> ：设置键值对</li><li><code>get key</code>：获取key对应的值</li><li><code>del key</code>：删除key</li><li><code>append key value</code>：以拼接形式添加值到key</li><li><code>strlen key</code>：获取key的长度</li><li><code>Incr/decr key</code>：自增 1 /自减 1（key对应value必须是数字）</li><li><code>Incrby / decrby key value</code>：以指定的value自增 / 自减 （key对应value必须是数字）</li><li><code>getrange key start end</code>：获取指定区间范围内的值，<strong>从0 到 -1 表示获取获取全部</strong></li><li><code>setrange key offset value</code>：设置指定取键范围内的值 ，offset是起始位置，value是覆盖的值</li><li><code>setex(set with expire) key second value </code>：设置key-value的<strong>同时设置过期时间</strong></li><li><code>setnx(set if not exist) key value</code>：设置key-value（前提是不存在该key）</li><li><code>mset k1 v1 k2 v2 k3 v3 ...</code>：同时设置一个或多个key-value</li><li><code>mget k1 k2 k3 ..</code>：同时获取一个或多个key的值</li><li><code>msetnx k1 v1 k2 v2 ... </code>：同时设置一个或多个key-value，当且仅当key都不存在<ul><li><strong>msetnx是一个原子操作</strong>（只要设置的key中存在一个就全部不设置）</li></ul></li><li><code>getset key value</code>：将给定的key的值设为value，并返回key的旧值</li></ul><h3 id="3-redis-列表（List）-–-常用命令"><a href="#3-redis-列表（List）-–-常用命令" class="headerlink" title="3.redis 列表（List） – 常用命令"></a>3.redis 列表（List） – 常用命令</h3><ul><li><p><code>lpush key element[element...]</code>：设置key，从左边（列表头）插入value</p></li><li><p><code>rpush key element[element...]</code>：设置key，从右边（列表尾）插入value</p></li><li><p><code>lrange key start stop</code>：获取指定区间范围内的值，从0 到 -1 表示获取获取全部</p></li><li><p><code>lindex key index</code>：按照索引下标值获得元素（从左向右）</p></li><li><p><code>llen key</code>：返回列表的长度</p></li><li><p><code>lrem key count element</code>：删除key中一共count个 值为element的元素</p><ul><li>count &gt; 0 ：从表头开始向表尾搜索，移除与 element 相等的元素，移除的数量为count </li><li>count &lt; 0 ：从表尾开始向表头搜索，移除与 element 相等的元素，移除的数量为count </li><li>count = 0 ：移除表中所有与 element 相等的值</li></ul></li><li><p><code>ltrim key start stop</code>：截取指定范围的值后再赋值给key</p></li><li><p><code>rpoplpush source destination</code>：移除列表source的最后一个元素，并将该元素添加到另一个列表destination头部，并返回</p></li><li><p><code>lset key index element</code>：将列表key下标为 index 的元素的值设置为element</p></li><li><p><code>linsert key BEFORE|AFTER pivot element</code>：将值element插入到列表key当中，位于位置pivot之前或之后</p><ul><li>当pivot不存在与列表key时，不执行任何操作</li><li>当key不存在时，key被视为空列表，不执行任何操作</li><li>如果key不是列表类型，返回一个类型</li></ul></li><li><p>注意点：list是一个字符串链表，left、right都可以插入添加</p><ul><li>如果key不存在，则创建新的列表</li><li>如果key已存在，新增内容value</li><li>如果值全移除，对应的key也就消失了</li><li>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡</li></ul></li></ul><h3 id="4-redis-集合（set）-–-常用命令"><a href="#4-redis-集合（set）-–-常用命令" class="headerlink" title="4. redis 集合（set） – 常用命令"></a>4. redis 集合（set） – 常用命令</h3><ul><li><p><code>sadd key member [member...]</code>：设置key，并往集合中添加元素member…</p></li><li><p><code>smembers key</code>：获取key集合中所有值 </p></li><li><p><code>sismember key member</code>：判断在集合key中是否存在元素member</p></li><li><p><code>scard key</code>：获取集合key里面的元素个数</p></li><li><p><code>srem key member [member...] </code>：删除集合中一个或多个元素</p></li><li><p><code>srandmember key [count]</code>：以数组形式返回key集合中 数量为count 个随机元素</p><ul><li>如果只提供了key参数，那么返回集合中一个随机元素</li><li>count &gt; 0 <ul><li>count 小于集合基数，返回一个包含count个元素的数组，且元素不重复</li><li>count 大于集合基数，返回整个集合</li></ul></li><li>count &lt; 0 ，返回一个数组，数组中的元素可能会重复出现，长度为count的绝对值</li></ul></li><li><p><code>spop key [count]</code>：移除并返回集合中的count个随机元素</p><ul><li>如果只提供了key参数，则移除并返回一个随机元素</li></ul></li><li><p><code>smove source destination member </code>：将member元素从 source 集合移动到 destination 集合</p></li><li><p><code>sdiff key [key ...]</code>：返回指定的多个key之间的<strong>差集</strong></p></li><li><p><code>sinter key [key ...] </code>：返回指定的多个key之间的<strong>交集</strong> </p></li><li><p><code>sunion key [key ...]</code>：返回指定的多个key之间的<strong>并集</strong></p></li></ul><h3 id="5-redis-哈希（Hash）-–-常用命令-（键-–-gt-键-–-值）"><a href="#5-redis-哈希（Hash）-–-常用命令-（键-–-gt-键-–-值）" class="headerlink" title="5. redis 哈希（Hash） – 常用命令 （键 –&gt; 键 – 值）"></a>5. redis 哈希（Hash） – 常用命令 （键 –&gt; 键 – 值）</h3><ul><li><p><code>hset key field value</code>：将哈希表key中的域 field 的值设为value</p></li><li><p><code>hget key field</code>：返回哈希表key 中指定 field 的值</p></li><li><p><code>hmset key field value [field value ...]</code>：同时将多个 field-value（域-值）对设置到哈希表key中</p></li><li><p><code>hmget key field [field ...]</code>：返回哈希表key中，一个或多个给定field的值</p></li><li><p><code>hgetall key</code>：返回哈希表key中，所有的域和值</p></li><li><p><code>hdel key field [field ...]</code>：删除哈希表key中一个或多个指定域field，不存在的域将被忽略</p></li><li><p><code>hlen key</code>：返回哈希表key中域的数量</p></li><li><p><code>hexists key field  </code>：查看哈希表key中，指定域field是否存在</p></li><li><p><code>hkeys key</code>：返回哈希表key中所有域field</p></li><li><p><code>hvals key</code>：返回哈希表key中所有域field的值value</p></li><li><p><code>hincrby key field increment</code>：将哈希表key中指定域field的值加上自增量increment</p></li><li><p><code>hincrbyfloat key field increment</code>：为哈希表key中指定域field加上浮点数增量increment</p></li><li><p><code>hsetnx key field value</code>：将哈希表key中的指定域field值设置为value，当且仅当域field不存在</p></li></ul><h3 id="6-redis-有序集合-ZSet（sorted-set）-–-常用命令"><a href="#6-redis-有序集合-ZSet（sorted-set）-–-常用命令" class="headerlink" title="6. redis 有序集合 ZSet（sorted set） – 常用命令"></a>6. redis 有序集合 ZSet（sorted set） – 常用命令</h3><ul><li><code>zdd key score member [[score member] ...]</code>：将一个或多个member元素及其score值加入到有序集key当中</li><li><code>zrange key start stop [WITHSCORES]</code> ：返回有序集key中，指定区间内的元素，并且返回顺序按照其score值<strong>从小到大</strong>排序<ul><li><strong>withscores</strong>：返回元素以及其score</li></ul></li><li><code>zrangebysocre key min max [WITHSCORES][LIMIT offset count]</code>：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员</li><li><code>zrem key member [member ...]</code>：移除有序集key中一个或多个指定的member，不存在的member将被忽略</li><li><code>zcard key</code>：返回有序集key的长度/基数</li><li><code>zcount key min max</code>：返回有序集key中score在 min 和 max 之间（包括值为min和max）的成员个数</li><li><code>zscore key member</code>：返回有序集key中，指定member的score值</li><li><code>zrevrange key start stop</code>： 返回有序集key中指定区间范围的member，返回顺序按照其score值<strong>从大到小</strong>来排序</li><li><code>zrevangebyscore key max min [WITHSCORES] [LIMIT offset count]</code>：返回有序集key中，score值介于min与max之间的所有member（包括值为min和max）。返回顺序按照score值递减（从大到小）来排序</li></ul><h2 id="四、解析配置文件"><a href="#四、解析配置文件" class="headerlink" title="四、解析配置文件"></a>四、解析配置文件</h2><h3 id="1-INCLUDES-—-gt-包含"><a href="#1-INCLUDES-—-gt-包含" class="headerlink" title="1. ### INCLUDES ###    —&gt;包含"></a>1. ### INCLUDES ###    —&gt;包含</h3><blockquote><p>与 Struts2配置文件类似，可以通过 includes 包含，redis.conf可以作为总闸，包含其他</p></blockquote><h3 id="2-GENREAL-—-gt-通用"><a href="#2-GENREAL-—-gt-通用" class="headerlink" title="2. ### GENREAL ###      —&gt;通用"></a>2. ### GENREAL ###      —&gt;通用</h3><ul><li><p><code>daemonize no</code></p><blockquote><p>Redis 默认不是以守护进程的方式运行，改为yes启用守护进程</p><p>启用守护进程后，Redis会将 pid 写入到 pidfile 中，路径为 /var/run/redis.pid</p></blockquote></li><li><p><code>pidfile /var/run/redis.pid</code></p><blockquote><p>当Redis以守护进程方式运行时，Redis会默认把 pid 写入到 /var/run/redis.pid  可以自定义路径</p></blockquote></li><li><p><code>port 6379</code></p><blockquote><p>指定 Redis 监听端口，默认为 6379</p><p>若指定 0 端口，表示Redis不监听任何 TCP 连接</p></blockquote></li><li><p><code>tcp-backlog 511</code></p><blockquote><p>设置tcp的backlog,backlog是一个连接队列</p><p>backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列</p><p>高并发环境下需要一个高backlog值来避免慢客户端连接问题</p><p>Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值）</p><p>所以需要增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果</p></blockquote></li><li><p><code>bind 127.0.0.1</code></p><blockquote><p>绑定的主机地址</p><p>如果没有绑定，所有接口都会监听到来的连接</p></blockquote></li><li><p><code>timeout 0</code></p><blockquote><p>客户端闲置多长时间后自动关闭连接，默认为0，表示永不关闭连接</p></blockquote></li><li><p><code>tcp-keepalive 0</code></p><blockquote><p>TCP连接保活策略，单位为秒</p><p>如果设置为0，则不会进行 Keepalive 检测，一般建议设置成 60</p></blockquote></li><li><p><code>loglevel notice</code></p><blockquote><p>指定日志记录级别</p><p>Redis支持四个级别：debug、verbose、notice、warning，默认为 notice</p></blockquote></li><li><p><code>logfile &quot;&quot;</code></p><blockquote><p>指定记录日志的文件，</p><p>默认为空字符串，日志会打印到标准输出设备</p><p>后台运行的 redis 标准输出 是 /dev/null</p></blockquote></li><li><p><code>syslog-enabled no</code></p><blockquote><p>是否把日志输出到 syslog 中</p></blockquote></li><li><p><code>syslog-ident redis</code></p><blockquote><p>指定 syslog 里的日志标志</p></blockquote></li><li><p><code>syslog-facility local0</code></p><blockquote><p>指定syslog设备，值可以是USER或LOCAL0-LOCAL7</p></blockquote></li><li><p><code>databases 16</code></p><blockquote><p>设置数据库数量，默认使用数据库为 0 </p></blockquote></li></ul><h3 id="3-SNAPSHOTTING-—-gt-快照（持久化实现）"><a href="#3-SNAPSHOTTING-—-gt-快照（持久化实现）" class="headerlink" title="3. ### SNAPSHOTTING ###   —&gt; 快照（持久化实现）"></a>3. ### SNAPSHOTTING ###   —&gt; 快照（持久化实现）</h3><ul><li><p><code>save</code> </p><blockquote><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件</p></blockquote><ul><li><code>save 900 1</code> ：900秒（15分钟）内有1个更改</li><li><code>save 300 10</code>：300秒（5分钟）内有10个更改</li><li><code>save 60 10000</code>：60秒（1分钟）内有10000个更改</li></ul></li><li><p><code>stop-writes-on-bgsave-error yes </code></p><blockquote><p>后台存储错误停止写</p></blockquote></li><li><p><code>rdbcompression yes</code></p><blockquote><p>指定存储至本地数据库时是否压缩数</p><p>Redis采用LZF压缩，为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变得巨大</p></blockquote></li><li><p><code>rdbchecksum yes</code></p><blockquote><p>存储快照后，还可以让redis使用 CRC64 算法来进行数据校验</p><p>数据校验过程会增加大约10%的性能消耗</p><p>如果希望获取最大的性能提升，可以关闭</p></blockquote></li><li><p><code>dbfilename dump.rdb</code></p><blockquote><p>指定本地数据库文件名，默认值为dump.rdb</p></blockquote></li><li><p><code>dir ./</code></p><blockquote><p>指定本地数据库存放目录 （rdb、aof文件都会写在这个目录）</p></blockquote></li></ul><h3 id="4-REPLICATION-—-gt-主从复制"><a href="#4-REPLICATION-—-gt-主从复制" class="headerlink" title="4. ### REPLICATION ###    —&gt; 主从复制"></a>4. ### REPLICATION ###    —&gt; 主从复制</h3><h3 id="5-SECURITY-—-gt-安全"><a href="#5-SECURITY-—-gt-安全" class="headerlink" title="5. ### SECURITY ###   —&gt;  安全"></a>5. ### SECURITY ###   —&gt;  安全</h3><ul><li><p><code>requirepass foobared</code></p><blockquote><p>设置 Redis 连接密码</p><p>配置了连接密码，客户端在连接 Redis 时需要通过<code>auth password</code>命令提供密码</p></blockquote></li></ul><h3 id="6-LIMITS-—-gt-极限"><a href="#6-LIMITS-—-gt-极限" class="headerlink" title="6. ### LIMITS ###   —&gt; 极限"></a>6. ### LIMITS ###   —&gt; 极限</h3><ul><li><p><code>maxclients 10000</code></p><blockquote><p>设置 Redis 的最大客户端连接量</p><p>当无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32</p><p>redis会为自身内部处理逻辑留一些句柄出来</p><p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应；</p></blockquote></li><li><p><code>maxmemory &lt;bytes&gt;</code></p><blockquote><p>设置 Redis 可以使用的内存量</p><p>一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定</p><p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需</p><p>要申请内存的指令返回错误信息（SET、LPUSH），对于无内存申请的指令，仍然会正常响应（GET）</p><p>如果当前redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出</p><p>一些内存空间给同步队列缓存，只有在设置的是“不移除”的情况下，才不用考虑这个因素</p></blockquote></li><li><p><code>maxmemory-policy noeviction</code></p><blockquote><p>数据淘汰策略，Redis提供6种淘汰策略</p><ul><li>volatile-lru ： 使用 LRU 算法移除key，只对设置了过期时间的键有效</li><li>allkeys-lru ：使用LRU 算法移除key</li><li>volatile-random ：在过期集合种移除随机的key，只对设置了过期时间的键有效</li><li>allkeys-random：随机移除key</li><li>volatile-ttl ：移除哪些TTL值最小的key，即最近要过期的key</li><li>noeviction ：不进行移除，针对写操作，只负责返回错误信息</li></ul></blockquote></li><li><p><code>maxmemory-samples 5</code></p><blockquote><p>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，</p><p>可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个</p></blockquote></li></ul><h3 id="7-APPEND-ONLY-MODE-—-gt-追加（持久化的实现之一）"><a href="#7-APPEND-ONLY-MODE-—-gt-追加（持久化的实现之一）" class="headerlink" title="7. ### APPEND ONLY MODE ###    —&gt; 追加（持久化的实现之一）"></a>7. ### APPEND ONLY MODE ###    —&gt; 追加（持久化的实现之一）</h3><ul><li><p><code>appendonly no</code></p><blockquote><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步把数据写入磁盘</p><p>不开启的情况下，可能会在断电时导致一段时间内的数据丢失，因为redis本身同步数据文件是按上面</p><p>save条件来同步的，所以有的数据会在一段时间内只存在于内存中</p></blockquote></li><li><p><code>appendfilename &quot;appendonly.aof&quot;</code></p><blockquote><p>指定更新日志文件名</p></blockquote></li><li><p><code>appendfsync everysec</code></p><blockquote><p><code>always</code>：同步持久化，每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好；<br><code>everysec</code>：出厂默认推荐，异步操作，每秒记录 如果一秒内宕机，有数据丢失；<br><code>no</code>：让操作系统来决定何时同步，不能给服务器性能带来多大的提升，而且也会增加系统奔溃时数据丢失的数量；</p></blockquote></li><li><p><code>no-appendfsync-on-rewrite no</code></p><blockquote><p>重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性</p></blockquote></li><li><p><code>auto-aof-rewrite-percentage 100</code></p><blockquote><p>重写指定百分比，为0会禁用AOF自动重写特性</p></blockquote></li><li><p><code>auto-aof-rewrite-min-size 64mb</code></p><blockquote><p>设置重写的基准值，当大于这个大小就会触发重写</p></blockquote></li></ul><p>摘自<a href="https://blog.csdn.net/qq_40804005/article/details/82919154">https://blog.csdn.net/qq_40804005/article/details/82919154</a></p><h3 id="常见的一些配置总结"><a href="#常见的一些配置总结" class="headerlink" title="### 常见的一些配置总结"></a>### 常见的一些配置总结</h3><blockquote><ul><li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br><code>daemonize yes</code></p></li><li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定<br><code>pidfile /var/run/redis.pid</code></p></li><li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字<br><code>port 6379</code></p></li><li><p>绑定的主机地址<br><code>bind 127.0.0.1</code></p></li><li><p>当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能<br><code>timeout 300</code></p></li><li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose<br><code>loglevel verbose</code></p></li><li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null<br><code>logfile stdout</code></p></li><li><p>设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id<br><code>databases 16</code></p></li><li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p><p><code>save seconds changes</code></p></li><li><p>Redis默认配置文件中提供了三个条件：</p><ul><li> save 900 1</li><li>save 300 10</li><li>save 60 10000</li><li>分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</li></ul></li><li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大<br><code>rdbcompression yes</code></p></li><li><p>指定本地数据库文件名，默认值为dump.rdb<br><code>dbfilename dump.rdb</code></p></li><li><p>指定本地数据库存放目录<br><code>dir ./</code></p></li><li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步<br><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></li><li><p>当master服务设置了密码保护时，slav服务连接master的密码<br><code>masterauth &lt;master-password&gt;</code></p></li><li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭<br><code>requirepass foobared</code></p></li><li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息<br><code>maxclients 128</code></p></li><li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区<br><code>maxmemory &lt;bytes&gt;</code></p></li><li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no<br><code>appendonly no</code></p></li><li><p>指定更新日志文件名，默认为appendonly.aof<br><code>appendfilename appendonly.aof</code></p></li><li><p>指定更新日志条件，共有3个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折衷，默认值）<br><code>appendfsync everysec</code></p></li><li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）<br><code>vm-enabled no</code></p></li><li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享<br><code>vm-swap-file /tmp/redis.swap</code></p></li><li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0<br><code>vm-max-memory 0</code></p></li><li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值<br><code>vm-page-size 32</code></p></li><li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。<br><code>vm-pages 134217728</code></p></li><li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4<br><code>vm-max-threads 4</code></p></li><li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<br><code>glueoutputbuf yes</code></p></li><li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法<br><code>hash-max-zipmap-entries 64</code><br><code>hash-max-zipmap-value 512</code></p></li><li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）<br><code>activerehashing yes</code></p></li><li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件<br><code>include /path/to/local.conf</code></p></li></ul></blockquote><h2 id="五、Redis的Java客户端-Jedis"><a href="#五、Redis的Java客户端-Jedis" class="headerlink" title="五、Redis的Java客户端 Jedis"></a>五、Redis的Java客户端 Jedis</h2><ul><li><h4 id="Maven环境下"><a href="#Maven环境下" class="headerlink" title="Maven环境下"></a>Maven环境下</h4><blockquote><ul><li><p>导入依赖包</p></li><li><p>配置redis.conf</p></li><li><p>自定义jedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 自定义RedisTemplate&lt;String, Object&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// String类型的序列化</span></span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// json类型的序列化</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        template.setHashValueSerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用jedisTemplate测试连接</p></li></ul></blockquote></li><li><h4 id="SpringBoot环境下"><a href="#SpringBoot环境下" class="headerlink" title="SpringBoot环境下"></a>SpringBoot环境下</h4><blockquote><ul><li><p>导入相关启动器</p></li><li><p>配置redis.conf</p></li><li><p>自定义jedisTemplate</p></li><li><p>配置 application.properties</p></li></ul> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Redis服务器地址</span><br><span class="line">spring.redis.host=47.103.4.117</span><br><span class="line">#Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">#Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database= 0</span><br><span class="line">#连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=1800000</span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.lettuce.pool.max-active=20</span><br><span class="line">#最大阻塞等待时间(负数表示没限制)</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1</span><br><span class="line">#连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=5</span><br><span class="line">#连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br></pre></td></tr></table></figure><ul><li>使用jedisTemplate测试</li></ul></blockquote></li></ul><p>参考文章：<a href="http://redisdoc.com/">http://redisdoc.com/</a></p><p>​                    <a href="https://blog.csdn.net/qq_40804005/article/details/82919154">https://blog.csdn.net/qq_40804005/article/details/82919154</a></p>]]></content>
    
    
    <summary type="html">Redis一些常用的命令</summary>
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>springMVC中mvc:annotation-driven的作用</title>
    <link href="http://example.com/2021/07/01/mvcannotation-driven%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/07/01/mvcannotation-driven%E8%A7%A3%E6%9E%90/</id>
    <published>2021-07-01T13:39:15.000Z</published>
    <updated>2021-09-17T19:46:29.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mvc-annotation-driven"><a href="#mvc-annotation-driven" class="headerlink" title="mvc:annotation-driven"></a>mvc:annotation-driven</h1><h1 id="mvc-default-servlet-handler的解析"><a href="#mvc-default-servlet-handler的解析" class="headerlink" title="mvc:default-servlet-handler的解析"></a>mvc:default-servlet-handler的解析</h1><h4 id="1-配置了-mvc-annotation-driven，但没有mvc-default-servlet-handler的情况"><a href="#1-配置了-mvc-annotation-driven，但没有mvc-default-servlet-handler的情况" class="headerlink" title="1. 配置了 mvc:annotation-driven，但没有mvc:default-servlet-handler的情况"></a>1. 配置了 mvc:annotation-driven，但没有mvc:default-servlet-handler的情况</h4><h5 id="作用效果是动态资源（jsp）可以访问，但静态资源无法访问"><a href="#作用效果是动态资源（jsp）可以访问，但静态资源无法访问" class="headerlink" title="作用效果是动态资源（jsp）可以访问，但静态资源无法访问"></a>作用效果是动态资源（jsp）可以访问，但静态资源无法访问</h5><p>原因：<br>  SpringMVC的九大组件之一的handlerMapping中有<strong>DefaultAnnotationHandlerMapping</strong>，它里面有一个<strong>handlerMap</strong>集合，<strong>该集合内部存放了基于注解形式的相关请求与对应处理方法的信息</strong><br>类似的，组件HandlerAdapter中也存放了处理器对应的适配器AnnotationMethodHandlerAdapter，提供动态资源处理方法的实现</p><h4 id="2-mvc-default-servlet-handler，但没有配置mvc-annotation-driven"><a href="#2-mvc-default-servlet-handler，但没有配置mvc-annotation-driven" class="headerlink" title="2. mvc:default-servlet-handler，但没有配置mvc:annotation-driven"></a>2. mvc:default-servlet-handler，但没有配置mvc:annotation-driven</h4><h5 id="作用效果是静态资源（html、js、img等）可以访问，但动态资源无法访问"><a href="#作用效果是静态资源（html、js、img等）可以访问，但动态资源无法访问" class="headerlink" title="作用效果是静态资源（html、js、img等）可以访问，但动态资源无法访问"></a>作用效果是静态资源（html、js、img等）可以访问，但动态资源无法访问</h5><p>原因：</p><p>handlerMapping根据配置项动态变化，<br>存放了动态资源访问信息的DefaultAnnotationHandlerMapping消失，替换成<strong>SimpleUrlHandlerMapping</strong>，<br><strong>它的作用是将所有请求交给服务器Tomcat处理</strong>，所以静态资源可以访问<br>同样地，HandlerAdapter中存放动态资源处理方法适配器AnnotationMethodHandlerAdapter，也被替换为<strong>SimpleControllerHandlerAdapter</strong><br>因此对于没有配置具体动态资源处理方法的服务器servlet，动态资源就无法被访问</p><h4 id="3-同时配置mvc-annotation-driven和mvc-default-servlet-handler"><a href="#3-同时配置mvc-annotation-driven和mvc-default-servlet-handler" class="headerlink" title="3. 同时配置mvc:annotation-driven和mvc:default-servlet-handler"></a>3. 同时配置mvc:annotation-driven和mvc:default-servlet-handler</h4><h5 id="作用效果：是动态、静态资源都可以访问"><a href="#作用效果：是动态、静态资源都可以访问" class="headerlink" title="作用效果：是动态、静态资源都可以访问"></a>作用效果：是动态、静态资源都可以访问</h5><p> 原理：<br> handlerMapping中的参数有三个：</p><h5 id="1-RequestMappingHandlerMapping：（优先度最高）提供动态资源的访问"><a href="#1-RequestMappingHandlerMapping：（优先度最高）提供动态资源的访问" class="headerlink" title="(1)RequestMappingHandlerMapping：（优先度最高）提供动态资源的访问"></a>(1)RequestMappingHandlerMapping：（优先度最高）提供动态资源的访问</h5><p>​    在其内部存放了两个关键集合：</p><ul><li><p>UrlMap：保存每个请求方式的映射信息</p></li><li><p>handlerMethods：存放了每个请求对应的处理方法</p></li></ul><blockquote><p>对比DefaultAnnotationHandlerMapping：更全面</p></blockquote><p>(2)BeanNameHandlerMapping（基于xml配置方式的处理方法，一直存在，但几乎不适用）</p><h5 id="3-SimpleUrlHandlerMapping：将请求转交给服务器Tomcat处理，提供静态资源的访问"><a href="#3-SimpleUrlHandlerMapping：将请求转交给服务器Tomcat处理，提供静态资源的访问" class="headerlink" title="(3)SimpleUrlHandlerMapping：将请求转交给服务器Tomcat处理，提供静态资源的访问"></a>(3)SimpleUrlHandlerMapping：将请求转交给服务器Tomcat处理，提供静态资源的访问</h5><p>HandlerAdapter其中的参数也有三个:</p><p>(1)HttpRequestHandlerAdapter（一直都存在，原生API处理方式的适配器）</p><h5 id="2-SimpleControllerHandlerAdapter：静态资源处理方法的适配器"><a href="#2-SimpleControllerHandlerAdapter：静态资源处理方法的适配器" class="headerlink" title="(2)SimpleControllerHandlerAdapter：静态资源处理方法的适配器"></a>(2)SimpleControllerHandlerAdapter：静态资源处理方法的适配器</h5><h5 id="3-RequestMappingHandlerAdapter：动态资源处理方法的适配器，"><a href="#3-RequestMappingHandlerAdapter：动态资源处理方法的适配器，" class="headerlink" title="(3)RequestMappingHandlerAdapter：动态资源处理方法的适配器，"></a>(3)RequestMappingHandlerAdapter：动态资源处理方法的适配器，</h5><blockquote><p>比原来AnnotationMethodHandlerAdapter的更高效</p></blockquote><h4 id="对于动态资源的请求的处理流程："><a href="#对于动态资源的请求的处理流程：" class="headerlink" title="对于动态资源的请求的处理流程："></a>对于动态资源的请求的处理流程：</h4><p>当请求处理到handlerMapping时，</p><ol><li>Spring会先判断系统的请求处理映射方式（基于xml配置or注释）选择对应的HandlerMapping</li><li>通过for循环，遍历查找HandlerMapping内部的映射关系，若找到可以处理该求的处理器（controller），返回该controller，由HandlerAdapter去真正地调用请求处理方法</li></ol><blockquote><p>动态资源的请求可以在RequestMappingHandlerMapping的handlerMethods中找到（前提是有对应的映射关系）</p></blockquote><h5 id="对于静态资源的请求，"><a href="#对于静态资源的请求，" class="headerlink" title="对于静态资源的请求，"></a>对于静态资源的请求，</h5><p>   当请求处理到handlerMapping时，在RequestMappingHandlerMapping和BeanNameHandlerMapping中都没找到处理方法，最后将请求转交给Tomcat处理</p>]]></content>
    
    
    <summary type="html">关于mvc:annotation-driven与mvc:default-servlet-handler</summary>
    
    
    
    
    <category term="SpringMVC" scheme="http://example.com/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
